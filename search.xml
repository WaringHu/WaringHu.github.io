<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>#1010 折半查找的实现</title>
    <url>/swustoj/1010/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>编写程序实现折半查找算法。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行是查找表的长度n<br>第二行是查找表中的数据元素 ；<br>第三行是要查找的数据元素的关键字。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>查找成功返回位序，不成功返回-1 ,第二行为比较的次数。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>11<br>5 13 19 21 37 56 64 75 80 88 92<br>100</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>-1<br>4</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (x &gt; arr[(start + end) / <span class="number">2</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((start + end) / <span class="number">2</span> + <span class="number">1</span> &gt; n - <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		Count++;</span><br><span class="line">		<span class="keyword">if</span> (find(x, arr, (start + end) / <span class="number">2</span> + <span class="number">1</span>, end, n))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (x &lt; arr[(start + end) / <span class="number">2</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((start + end) / <span class="number">2</span> + <span class="number">1</span> &gt; n - <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		Count++;</span><br><span class="line">		<span class="keyword">if</span>(find(x, arr, start, (start + end) / <span class="number">2</span> - <span class="number">1</span>,n))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x == arr[(start + end) / <span class="number">2</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		position = (start + end) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		arr.push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	sort(arr.begin(),arr.end());</span><br><span class="line">	<span class="keyword">if</span> (find(x, arr, <span class="number">0</span>, n - <span class="number">1</span>, n))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; position&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Count;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1011 二叉排序树的实现和查找</title>
    <url>/swustoj/1011/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>按照给定的关键字集合，建立二叉排序树。在建立的二叉排序树上查找指定的关键字，查找成功，输出找到该关键字比较的次数；查找不成功，输出-1.</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>关键字个数n；<br>关键字集合；<br>要查找的关键字。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>查找成功输出比较的次数，否则输出-1。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>12<br>25 18 46 2 53 39 32 4 74 67 60 11<br>74</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>4</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">tree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	treenode(<span class="keyword">int</span> a) :data(a)</span><br><span class="line">	&#123;</span><br><span class="line">		left = <span class="literal">NULL</span>;</span><br><span class="line">		right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	treenode* left;</span><br><span class="line">	treenode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tree() :root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(treenode*  &amp; T,treenode*&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,treenode* current)</span></span>;</span><br><span class="line">	treenode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::insert</span><span class="params">(treenode* &amp; T,treenode* &amp;current)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = T;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;data&gt;T-&gt;data)</span><br><span class="line">	&#123;</span><br><span class="line">		insert(T, current-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;data &lt; T-&gt;data)</span><br><span class="line">	&#123;</span><br><span class="line">		insert(T, current-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree::find</span><span class="params">(<span class="keyword">int</span> x,treenode* current)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;data == x)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> Count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; current-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;right)</span><br><span class="line">			&#123;</span><br><span class="line">				Count++;</span><br><span class="line">				find(x,current-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; current-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">			&#123;</span><br><span class="line">				Count++;</span><br><span class="line">				find(x, current-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree T;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x; </span><br><span class="line">		treenode* temp = <span class="keyword">new</span> treenode(x);</span><br><span class="line">		T.insert(temp,T.root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	T.find(a, T.root);</span><br><span class="line">	<span class="keyword">if</span> (flag==<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Count;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1012 哈希表（链地址法处理冲突）</title>
    <url>/swustoj/1012/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>采用除留余数法（H（key）=key %n）建立长度为n的哈希表，处理冲突用链地址法。建立链表的时候采用尾插法。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为哈西表的长度m；<br>第二行为关键字的个数n；<br>第三行为关键字集合；<br>第四行为要查找的数据。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>如果查找成功，输出该关键字所在哈希表中的地址和比较次数；如果查找不成功，输出-1。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>13<br>13<br>16 74 60 43 54 90 46 31 29 88 77 78 79<br>16</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>3,1</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashmap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	hashmap(<span class="keyword">int</span> size = <span class="number">1000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		arr.resize(size);</span><br><span class="line">		sizement = size;</span><br><span class="line">		currentsize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> hashval = n%sizement;</span><br><span class="line">		<span class="keyword">return</span> hashval;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = hash(n);</span><br><span class="line">		arr[pos].push_back(n);</span><br><span class="line">		currentsize++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="keyword">int</span> pos = hash(n);</span><br><span class="line">		<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">		<span class="keyword">for</span> (iter = arr[pos].begin(); iter != arr[pos].end(); iter++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*iter == n)</span><br><span class="line">			&#123;</span><br><span class="line">				x= *iter;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				Count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x == n)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> pos;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;                                                     </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> currentsize;</span><br><span class="line">	<span class="keyword">int</span> sizement;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt; arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function">hashmap <span class="title">H</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		H.put(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> pos = H.get(k);</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; Count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1013 哈希表（开放定址法处理冲突）</title>
    <url>/swustoj/1013/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>采用除留余数法（H（key）=key %n）建立长度为n的哈希表，处理冲突用开放定址法的线性探测。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为哈希表的长度n；<br>第二行为关键字的个数；<br>第三行为关键字集合；<br>第四行为要查找的数据。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>如果查找成功，输出关键字所哈希表中的地址和比较次数；<br>如果查找不成功，输出-1。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>13<br>11<br>16 74 60 43 54 90 46 31 29 88 77<br>16</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>3,1</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashmap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	hashmap(<span class="keyword">int</span> size = <span class="number">1000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		arr.resize(size);</span><br><span class="line">		sizement = size;</span><br><span class="line">		currentsize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> hashval = n%sizement;</span><br><span class="line">		<span class="keyword">return</span> hashval;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> pos = hash(n);</span><br><span class="line">		<span class="keyword">if</span> (arr[pos]==<span class="literal">NULL</span>)</span><br><span class="line">		arr[pos]=n;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (arr[pos] != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				pos++;</span><br><span class="line">				<span class="keyword">if</span> (pos &gt; sizement - <span class="number">1</span>)</span><br><span class="line">					pos = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[pos] = n;</span><br><span class="line">		&#125;</span><br><span class="line">		currentsize++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="keyword">int</span> pos = hash(n);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; sizement;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			x = arr[i];</span><br><span class="line">			<span class="keyword">if</span> (x == n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				Count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x == n)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> pos;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;                                                     </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> currentsize;</span><br><span class="line">	<span class="keyword">int</span> sizement;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function">hashmap <span class="title">H</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		H.put(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> pos = H.get(k);</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; Count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1027 舞伴问题</title>
    <url>/swustoj/1027/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。要求编写程序实现舞伴问题。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入一共5行，第一行是男生人数m；第二行依次是男生的姓名；第三行是女士的人数n；第四行依次是女士的姓名；第五行是跳舞的轮数。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>配对的男士和女士的姓名。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>A B C D E<br>3<br>F G H<br>2</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>B G</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; Q1,Q2;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		Q1.push(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">		Q2.push(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x;				<span class="comment">//几轮跳舞</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; x; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> f1 = Q1.front();</span><br><span class="line">		<span class="keyword">char</span> f2 = Q2.front();</span><br><span class="line">		Q1.pop();</span><br><span class="line">		Q2.pop();</span><br><span class="line">		Q1.push(f1);</span><br><span class="line">		Q2.push(f2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Q1.front() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Q2.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1028 特定字符序列的判断</title>
    <url>/swustoj/1028/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>编写一程序，识别依次读入的一个以“#”为结束符的字符序列是否为形如“序列1@序列2”模式的字符序列。期中序列1和序列2中都不含字符“@”，且序列2是序列1的逆序列。例如“a+b@b+a”是满足条件的序列字符，而“1+3@3-1”则不是。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>一个以“#”结束的字符序列。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>是满足条件的字符序列输出“yes!”；否则输出“no!”。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>a+b@b+a#</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>yes!</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> a;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	a.c_str();</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; List1,List2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; a[i] != <span class="string">&#x27;#&#x27;</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] != <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">			List1.push_back(a[i]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; a[j] != <span class="string">&#x27;#&#x27;</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				List2.push_front(a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator p;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator q;</span><br><span class="line">	<span class="keyword">for</span> (p = List1.begin(), q = List2.begin(); p != List1.end() &amp;&amp; q != List2.end(); p++, q++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*p != *q)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no!&quot;</span> ;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yes!&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1035 定位顺序表中的最大和最小值</title>
    <url>/swustoj/1035/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>建立长度为n的顺序表，在表中找出最大值和最小值元素所在的位置。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为顺序表的长度n；<br>第二行为顺序表中的数据元素；</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>第一行为最大值的位置；第二行为最小值的位置。<br>本题输出格式：第一行输出需换行，第二行输出无需换行。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>7<br>1 2 3 4 5 6 7</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>Lmax=6<br>Lmin=0</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> min=arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> Min = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt;= max)</span><br><span class="line">		&#123;</span><br><span class="line">			Max = i;</span><br><span class="line">			max = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt;= min)</span><br><span class="line">		&#123;</span><br><span class="line">			min = arr[i];</span><br><span class="line">			Min = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lmax=&quot;</span> &lt;&lt;Max &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Lmin=&quot;</span> &lt;&lt; Min &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1037 集合的并运算的实现</title>
    <url>/swustoj/1037/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设有两个集合 A 和 B 分别用两个线性表 LA 和 LB 表示，即线性表中的数据元素即为集合中的成员。编程实现集合A和集合B的并运算。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为集合A的数据元素个数n 第二行输入n个集合A的数据元素 第三行为集合B的数据元素的个数； 第四行输入m个集合B的数据元素。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>第一行为A和B的并集.</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>8<br>0 5 6 3 8 7 9 10<br>7<br>1 3 4 7 8 9 5</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>0 5 6 3 8 7 9 10 1 4 </p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr1[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> arr2[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr1[i];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr2[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr2[i] == arr1[j])</span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			arr1[k] = arr2[i];</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; arr1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1036 寻找整数序列的主元素</title>
    <url>/swustoj/1036/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>已知一个整数序列A=（a0，a1，…an），如果其中有一个元素的出现次数超过n/2，就称该元素为A的主元素，否则就称整数序列没有主元素。例如A=（0，5，5，3，5，7，5，5），则5为主元素。A=（0，5，5，3，5，1，5，7），则A中没有主元素。要求编写程序实现寻找给定整数序列的主元素，如果找到，则输出主元素。如果没有找到，则输出-1。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为整数序列的个数n<br>第二行为一个整数序列。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>如果找到主元素，输出主元素的值，否则输出-1。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>8<br>0 5 5 3 5 7 5 5</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>5</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> count[<span class="number">1000</span>] = &#123; <span class="number">-1</span> &#125;;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] == arr[j])</span><br><span class="line">				count[i]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (count[i] &gt; n / <span class="number">2</span>)</span><br><span class="line">			flag = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; count[flag];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1038 顺序表中重复数据的删除</title>
    <url>/swustoj/1038/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>将存储在顺序表中的长度为n的线性表中指定的数据全部删除。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为顺序表的长度n； 第二行为顺序表中的数据元素； 第三行为指定要删除的元素值。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>如果表不空，输出删除指定值后的线性表；如果删除后表空，则输出-1。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>8<br>11 22 33 44 44 55 44 66<br>44</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>11 22 33 55 66</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i][<span class="number">0</span>] == x)</span><br><span class="line">		&#123;</span><br><span class="line">			arr[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i][<span class="number">1</span>] != <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; arr[i][<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count == n)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1044 顺序栈基本操作的实现</title>
    <url>/swustoj/1044/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>编程实现顺序栈的初始化、入栈、出栈、取栈顶元素和计算栈中元素个数等基本操作。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为入栈元素的个数；<br>第二行依次为入栈的元素；<br>出栈操作的次数n.</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出n次出栈后的栈顶元素值。<br>如果是空栈，输出-1.</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>4<br>1 2 3 4<br>2</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>2</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; St;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">		St.push(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x&amp;&amp;!St.empty(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		St.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (St.empty())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; St.top();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1045 集合的交运算的实现</title>
    <url>/swustoj/1045/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设有两个集合 A 和 B 分别用两个线性表 LA 和 LB 表示，即线性表中的数据元素即为集合中的成员。编程实现集合A和集合B的交运算。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为集合A的数据元素个数n;<br>第二行输入n个集合A的数据元素 ;<br>第三行为集合B的数据元素的个数；<br>第四行输入m个集合B的数据元素</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>A和B的交集</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>8<br>0 5 6 3 8 7 9 10<br>7<br>1 3 4 7 8 9 5</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>5 3 8 7 9</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; St;</span><br><span class="line">	<span class="keyword">int</span> arr1[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> arr2[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr1[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr2[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr1[i] == arr2[j])</span><br><span class="line">			&#123;</span><br><span class="line">				St.push(arr1[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!St.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; St.front()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		St.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1051 输出利用先序遍历创建的二叉树中的指定结点的孩子结点</title>
    <url>/swustoj/1051/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并输出该二叉树中指定结点的儿子结点。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再输出创建完成的二叉树中的指定结点的儿子结点。注意输入数据序列中的”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入用例分2行输入，第一行接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树），第二行为指定的结点数据。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>用一行输出该用例对应的二叉树中指定结点的儿子结点，格式为：L:*,R:*。若相应儿子不存在则以”#”。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>A##<br>A<br>ABC####<br>B</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>L:#,R:#<br>L:C,R:#</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> L, R;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">tree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	treenode(<span class="keyword">char</span> a) :data(a)</span><br><span class="line">	&#123;</span><br><span class="line">		left = <span class="literal">NULL</span>;</span><br><span class="line">		right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	treenode* left;</span><br><span class="line">	treenode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tree() :root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">precreate</span><span class="params">(treenode* &amp; current, <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;Q)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">find_left</span><span class="params">(treenode* current, <span class="keyword">char</span> a)</span></span>;</span><br><span class="line">	treenode* root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::precreate</span><span class="params">(treenode* &amp; current, <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Q.front() == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">		Q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> treenode(Q.front());</span><br><span class="line">		Q.pop();</span><br><span class="line">		precreate(current-&gt;left, Q);</span><br><span class="line">		precreate(current-&gt;right, Q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::find_left</span><span class="params">(treenode* current, <span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;data == a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">		&#123;</span><br><span class="line">			L = current-&gt;left-&gt;data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			L = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;right)</span><br><span class="line">		&#123;</span><br><span class="line">			R = current-&gt;right-&gt;data;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			R = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">			find_left(current-&gt;left, a);</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;right, a)</span><br><span class="line">			find_left(current-&gt;right, a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree T;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; Q;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; arr[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.push(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	T.precreate(T.root, Q);</span><br><span class="line">	<span class="keyword">char</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	T.find_left(T.root, x);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L:&quot;</span> &lt;&lt; L ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;R:&quot;</span> &lt;&lt; R ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1046 链栈基本操作的实现</title>
    <url>/swustoj/1046/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>编程实现链栈的初始化、入栈、出栈和计算栈中元素个数等基本操作。（测试数据为整数。）</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为入栈元素的个数;<br>第二行为入栈元素；<br>出栈操作的次数n。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>n次出栈后的栈顶元素。<br>如果是空栈，输出-1。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>4<br>1 2 3 4<br>2</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>2</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; St;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">		St.push(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x&amp;&amp;!St.empty(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		St.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (St.empty())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; St.top();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1052  输出利用先序遍历创建的二叉树中的指定结点的双亲结点</title>
    <url>/swustoj/1052/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并输出该二叉树中指定结点的双亲结点。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符“#”时表示该结点不需要创建，否则创建该结点。最后再输出创建完成的二叉树中的指定结点的双亲结点。注意输入数据序列中的“#”字符和非“#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入用例分2行输入，第一行接受键盘输入的由大写英文字符和“#”字符构成的一个字符串（用于创建对应的二叉树），第二行为指定的结点数据。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>用一行输出该用例对应的二叉树中指定结点的双亲结点。若相应双亲结点不存在则以“#”代替。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>A##<br>A<br>ABC####<br>B</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>#<br>A</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> parent=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">tree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	treenode(<span class="keyword">char</span> a) :data(a)</span><br><span class="line">	&#123;</span><br><span class="line">		left = <span class="literal">NULL</span>;</span><br><span class="line">		right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	treenode* left;</span><br><span class="line">	treenode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tree() :root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">precreate</span><span class="params">(treenode* &amp; current, <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;Q)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">find_left</span><span class="params">(treenode* current, <span class="keyword">char</span> a)</span></span>;</span><br><span class="line">	treenode* root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::precreate</span><span class="params">(treenode* &amp; current, <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Q.front() == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">		Q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> treenode(Q.front());</span><br><span class="line">		Q.pop();</span><br><span class="line">		precreate(current-&gt;left, Q);</span><br><span class="line">		precreate(current-&gt;right, Q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::find_left</span><span class="params">(treenode* current, <span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;data == a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">		&#123;</span><br><span class="line">			parent = current-&gt;data;</span><br><span class="line">			find_left(current-&gt;left, a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;right)</span><br><span class="line">		&#123;</span><br><span class="line">			parent = current-&gt;data;</span><br><span class="line">			find_left(current-&gt;right, a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree T;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; Q;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; arr[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.push(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	T.precreate(T.root, Q);</span><br><span class="line">	<span class="keyword">char</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	T.find_left(T.root, x);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; parent;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1055 邻接矩阵到邻接表</title>
    <url>/swustoj/1055/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设无向图G采用邻接矩阵存储，编写一个算法输出邻接表。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为一个整数n，表示顶点的个数（顶点编号为0到n-1），接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为0表示不邻接，1表示邻接。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出图G的邻接表。第一行表示顶点0可直接到达的顶点编号。其他行定义相同。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>0 1 0 1 1<br>1 0 1 1 0<br>0 1 0 1 1<br>1 1 1 0 1<br>1 0 1 1 0</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>134<br>023<br>134<br>0124<br>023</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m, k;</span><br><span class="line">	<span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; n; m++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[m][k] == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1053 输出利用先序遍历创建的二叉树中的指定结点的度</title>
    <url>/swustoj/1053/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并输出该二叉树中指定结点的度。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符“#”时表示该结点不需要创建，否则创建该结点。最后再输出创建完成的二叉树中的指定结点的度。注意输入数据序列中的字符“#”和非“#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入用例分2行输入，第一行接受键盘输入的由大写英文字符和“#”字符构成的一个字符串（用于创建对应的二叉树），第二行为指定的结点数据。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>用一行输出该用例对应的二叉树中指定结点的度。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>A##<br>A<br>ABC####<br>B</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>0<br>1</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Count=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">tree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	treenode(<span class="keyword">char</span> a) :data(a)</span><br><span class="line">	&#123;</span><br><span class="line">		left = <span class="literal">NULL</span>;</span><br><span class="line">		right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	treenode* left;</span><br><span class="line">	treenode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tree() :root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">precreate</span><span class="params">(treenode* &amp; current, <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;Q)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">find_left</span><span class="params">(treenode* current, <span class="keyword">char</span> a)</span></span>;</span><br><span class="line">	treenode* root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::precreate</span><span class="params">(treenode* &amp; current, <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Q.front() == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">		Q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> treenode(Q.front());</span><br><span class="line">		Q.pop();</span><br><span class="line">		precreate(current-&gt;left, Q);</span><br><span class="line">		precreate(current-&gt;right, Q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::find_left</span><span class="params">(treenode* current, <span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;data == a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">			Count++;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;right)</span><br><span class="line">			Count++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">		&#123;</span><br><span class="line">			find_left(current-&gt;left, a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;right)</span><br><span class="line">		&#123;</span><br><span class="line">			find_left(current-&gt;right, a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree T;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; Q;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; arr[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.push(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	T.precreate(T.root, Q);</span><br><span class="line">	<span class="keyword">char</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	T.find_left(T.root, x);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Count;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1056 邻接表到邻接矩阵</title>
    <url>/swustoj/1056/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设无向图G采用邻接表存储，编写一个算法输出邻接矩阵。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为一个整数n，表示顶点的个数（顶点编号为0到n-1）。第二行表示顶点0可直接到达的顶点编号，其他行定义相同。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出图G的邻接矩阵。整数矩阵大小为n*n，表示图的邻接关系。数字为0表示不邻接，1表示邻接。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>1 3 4<br>0 2 3<br>1 3 4<br>0 1 2 4<br>0 2 3</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>01011<br>10110<br>01011<br>11101<br>10110</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n;i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		arr[i][j] = <span class="number">0</span>;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			a = getchar(); </span><br><span class="line">			<span class="keyword">if</span> (a == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			arr[i][a - <span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1057 有向图的出度计算</title>
    <url>/swustoj/1057/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设有向图G采用邻接表存储，设计算法求出图G中每个顶点的出度。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为图中顶点的个数n 第二行为图的边的条数e 第三行为依附于一条边的两个顶点的数据信息。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>图G中每个顶点的出度。第一行表示顶点0的出度，其他行定义相同。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>6<br>0 1<br>0 3<br>1 2<br>1 3<br>4 0<br>4 3</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>2<br>2<br>0<br>0<br>2</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		count[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">1000</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i][<span class="number">0</span>];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i][<span class="number">1</span>];</span><br><span class="line">		count[arr[i][<span class="number">0</span>]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; count[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1058 无向图顶点度的计算</title>
    <url>/swustoj/1058/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设无向图G采用邻接矩阵存储，设计算法求出图G中每个顶点的度。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为一个整数n，表示顶点的个数（顶点编号为0到n-1）。接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为0表示不邻接，1表示邻接。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>图G中每个顶点的度。第一行表示顶点0的度，其他行定义相同。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>0 1 0 1 1<br>1 0 1 1 0<br>0 1 0 1 1<br>1 1 1 0 1<br>1 0 1 1 0</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>3<br>3<br>3<br>4<br>3</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">			<span class="keyword">if</span> (arr[i][j] == <span class="number">1</span>)</span><br><span class="line">				count[i]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; count[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1059 有向图的最大出度计算</title>
    <url>/swustoj/1059/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设有向图G采用邻接表存储，求出图G中出度最大的顶点，并输出顶点的编号（有多个结果的都要输出）。（顶点的数据元素为整型数据。）</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为图中顶点的个数n； 第二行为图的边的条数e； 第三行为依附于一条边的两个顶点信息。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>图G中出度的最大值以及顶点编号。第一行表示最大出度，第二行表示所有顶点的编号。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>6<br>0 1<br>0 3<br>1 2<br>1 3<br>4 0<br>4 3</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>2<br>014</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		count[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">1000</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i][<span class="number">0</span>];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i][<span class="number">1</span>];</span><br><span class="line">		count[arr[i][<span class="number">0</span>]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> arr1[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (count[i] &gt;= max)</span><br><span class="line">			max = count[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (count[i] == max)</span><br><span class="line">		&#123;</span><br><span class="line">			arr1[j] = i;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; arr1[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1060 无向图的最大度计算</title>
    <url>/swustoj/1060/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设无向图G采用邻接矩阵存储，求出图G最大度值并输出顶点的编号（有多个结果的都要输出）。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为一个整数n，表示顶点的个数（顶点编号为0到n-1）。接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为0表示不邻接，1表示邻接。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>图G中度的最大值以及顶点编号。第一行表示最大度值，第二行表示所有顶点的编号。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>0 1 0 1 1<br>1 0 1 1 1<br>0 1 0 1 1<br>1 1 1 0 1<br>1 1 1 1 0</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>4<br>134</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> count[<span class="number">100</span>];</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">int</span> arr[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">				<span class="keyword">if</span> (arr[i][j] == <span class="number">1</span>)</span><br><span class="line">					count[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> arr1[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (count[i]&gt;max)</span><br><span class="line">			max = count[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (count[i] == max)</span><br><span class="line">		&#123;</span><br><span class="line">			arr1[j] = i;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; arr1[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1061 有向图的k出度计算</title>
    <url>/swustoj/1061/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设有向图G采用邻接矩阵存储，计算图G中出度为k的顶点数量，并输出顶点的编号。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行第一个整数n表示顶点的个数（顶点编号为0到n-1），第二个数表示出度k，接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为0表示不邻接，1表示不邻接。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>图G中出度为k顶点数量以及顶点编号。第一行表示出度为k顶点数量，第二行表示顶点的编号。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5 2<br>0 1 0 1 0<br>0 0 1 1 0<br>0 0 0 0 0<br>0 0 0 0 0<br>1 0 0 1 0</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>3<br>014</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> count[<span class="number">100</span>];</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; k; </span><br><span class="line">		<span class="keyword">int</span> arr[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">				<span class="keyword">if</span> (arr[i][j] == <span class="number">1</span>)</span><br><span class="line">					count[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">int</span> arr1[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (count[i] == k)</span><br><span class="line">		&#123;</span><br><span class="line">			arr1[j] = i;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; arr1[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1062 有向图的边存在判断</title>
    <url>/swustoj/1062/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设有向图G采用邻接矩阵存储，判断图G中是否存在边。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行第一个整数n表示顶点的个数（顶点编号为0到n-1），第二行表示顶点i和j，接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为0表示不邻接，1表示不邻接。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>yes（存在），no（不存在）。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>0 2<br>0 1 0 1 0<br>0 0 1 1 0<br>0 0 0 0 0<br>0 0 0 0 0<br>1 0 0 1 0</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>no</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> m, k;</span><br><span class="line">	<span class="keyword">int</span> count[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">			<span class="keyword">if</span> (arr[i][j] == <span class="number">1</span> &amp;&amp; i == m&amp;&amp;j == k)</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1063 带权有向图计算</title>
    <url>/swustoj/1063/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设带权有向图G采用邻接矩阵存储，计算图的最大权值、最小权值以及对应的有向边。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行第一个整数n表示顶点的个数（顶点编号为0到n-1），第二行表示顶点i和j，接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为大于0表示邻接值，-1表示不邻接，对角线为0。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>第一行为最大权值，第二行为有向边。第三行为最小权值，第四行为有向边。<br>由于OJ无法显示尖括号，所以这里用圆扩号来表示有序对。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>0 5 -1 23 -1<br>-1 0 31 56 -1<br>-1 -1 0 -1 -1<br>-1 -1 -1 0 -1<br>56 -1 -1 19 0</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>56<br>(1 3)(4 0)<br>5<br>(0 1)<br>注意：由于显示的问题，输出数据应采用尖括号。</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count1[<span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> count2[<span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> min = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">			<span class="keyword">if</span> (arr[i][j] &gt;= <span class="number">0</span>&amp;&amp;i!=j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (min == <span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					min = arr[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (arr[i][j] &lt;= min)</span><br><span class="line">				&#123;</span><br><span class="line">					min = arr[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (arr[i][j] &gt;= max)</span><br><span class="line">				&#123;</span><br><span class="line">					max = arr[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i][j] == max)</span><br><span class="line">			&#123;</span><br><span class="line">				count1[m][<span class="number">0</span>] = i;</span><br><span class="line">				count1[m][<span class="number">1</span>] = j;</span><br><span class="line">				m++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (arr[i][j] == min)</span><br><span class="line">			&#123;</span><br><span class="line">				count2[n][<span class="number">0</span>] = i;</span><br><span class="line">				count2[n][<span class="number">1</span>] = j;</span><br><span class="line">				n++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; max &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;&lt;&#x27;</span> &lt;&lt; count1[i][<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; count1[i][<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; min &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;&lt;&#x27;</span> &lt;&lt; count2[i][<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; count2[i][<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1064 带权无向图存储判定</title>
    <url>/swustoj/1064/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设无向图G采用邻接矩阵存储，判断输入数据格式是否正确（即是否为对称矩阵）。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行第一个整数n表示顶点的个数（顶点编号为0到n-1），接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为大于0表示邻接值，-1表示不邻接，对角线为0。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>yes（正确），no（错误）。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>0 6 -1 22 1<br>6 0 1 1 -1<br>-1 1 0 1 1<br>22 1 1 0 9<br>1 -1 1 9 0</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>yes</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j&amp;&amp;arr[i][j] != <span class="number">0</span>)</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (arr[i][j] != arr[j][i])</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1065 无向图的连通分量计算</title>
    <url>/swustoj/1065/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>假设无向图G采用邻接矩阵存储，编写一个算法求连通分量的个数。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为一个整数n，表示顶点的个数（顶点编号为0到n-1），接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为0表示不邻接，1表示不邻接。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>连通分量的个数。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>0 1 0 1 1<br>1 0 1 1 0<br>0 1 0 1 1<br>1 1 1 0 1<br>1 0 1 1 0</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++, k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i][j] != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				temp[i] = <span class="number">1</span>;</span><br><span class="line">				temp[j] = <span class="number">1</span>;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (temp[i] == <span class="number">0</span> &amp;&amp; temp[j] == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					temp[i] = <span class="number">1</span>;</span><br><span class="line">					temp[j] = <span class="number">1</span>;</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1068 图的按录入顺序深度优先搜索</title>
    <url>/swustoj/1068/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>图的深度优先搜索类似于树的先根遍历，即从某个结点开始，先访问该结点，然后深度访问该结点的第一棵子树，依次为第二顶子树。如此进行下去，直到所有的结点都访问为止。在该题中，假定所有的结点以“A”至“Z”中的若干字符表示，且要求结点的访问顺序根据录入的顺序进行访问。如果结点录入的顺序为HUEAK，从H开始进行深度优先搜索，则可能的搜索结果为：H-&gt;A-&gt;K-&gt;U&gt;E.</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为一个整数n，表示顶点的个数，第二行为n个大写字母构成的字符串，表示顶点，接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为0表示不邻接，否则为相应的边的长度。最后一行为一个字符，表示要求进行深度优先搜索的起始顶点。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>用一行输出深度优先搜索结果，起始点为给定的顶点。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>HUEAK<br>0 0 2 3 0<br>0 0 0 7 4<br>2 0 0 0 0<br>3 7 0 0 1<br>0 4 0 1 0<br>H</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>HEAUK</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">char</span> strr[<span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		strr[i][<span class="number">0</span>] = str[i];</span><br><span class="line">		strr[i][<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (strr[i][<span class="number">0</span>] == a)</span><br><span class="line">		&#123;</span><br><span class="line">			b = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	strr[b][<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">	s.push(b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; strr[b][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">while</span> (s.size()&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> v = s.top();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[v][i] &gt;<span class="number">0</span> &amp;&amp; strr[i][<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				x = i;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			strr[x][<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; strr[x][<span class="number">0</span>];</span><br><span class="line">			s.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			s.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1069 图的按录入顺序广度优先搜索</title>
    <url>/swustoj/1069/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>图的广度优先搜索类似于树的按层次遍历，即从某个结点开始，先访问该结点，然后访问该结点的所有邻接点，再依次访问各邻接点的邻接点。如此进行下去，直到所有的结点都访问为止。在该题中，假定所有的结点以“A”–“Z”中的若干字符表示，且要求结点的访问顺序根据录入的顺序进行访问。如果结点录入的顺序为HUEAK，要求从H开始进行广度优先搜索，则可能的搜索结果为：H-&gt;E-&gt;A-&gt;U-&gt;K.</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为一个整数n，表示顶点的个数，第二行为n个大写字母构成的字符串，表示顶点，接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为0表示不邻接，否则为相应的边的长度。最后一行为一个字符，表示要求进行广度优先搜索的起始顶点。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>用一行输出广度优先搜索结果，起始点为给定的顶点。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>HUEAK<br>0 0 2 3 0<br>0 0 0 7 4<br>2 0 0 0 0<br>3 7 0 0 1<br>0 4 0 1 0<br>H</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>HEAUK</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">char</span> strr[<span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		strr[i][<span class="number">0</span>] = str[i];</span><br><span class="line">		strr[i][<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (strr[i][<span class="number">0</span>] == a)</span><br><span class="line">		&#123;</span><br><span class="line">			b = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	strr[b][<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">	s.push(b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; strr[b][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">while</span> (s.size()&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> v = s.front();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[v][i] &gt;<span class="number">0</span> &amp;&amp; strr[i][<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				strr[i][<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; strr[i][<span class="number">0</span>];</span><br><span class="line">				s.push(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1101 顺序表中数据的循环移动</title>
    <url>/swustoj/1101/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>设有长度为n（n&gt;1）的顺序表R，将R中保存的序列循环左移P（0 &lt; P &lt; n）个位置，即将R中的数据由（x0,x1,…,xn-1）变换为(xp,xp+1,…,xn-1,x0,x1,…,xp-1)。如果p值不合法，输出“error！”。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为数据元素个数n；<br>第二行为n个整数；<br>第三行为要左移的位数p。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>移动后的序列。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>10<br>1 2 3 4 5 6 7 8 9 10<br>5</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>6 7 8 9 10 1 2 3 4 5</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> n, a;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">		Q.push(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= n || x &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error!&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	x %= n;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		Q.push(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Q.front() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		Q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1167 分离字符串</title>
    <url>/swustoj/1167/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>分离字符串中的不同字符单独成行输出</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>多组测试数据,每组测试数据仅一行字符串(不含空格,字符串长度小于等于200).</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>分离字符串中的数字、字母、特殊字(分离的时候字符顺序不要变).<br>输出为三行:<br>第一行为字母,<br>第二行为数字,<br>第三行为特殊字符.</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>c5430-456cm9203,’36.g64x4/546[45v];;v5642/;;432</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>ccmgxvv<br>5430456920336644546455642432<br>-,’./[];;/;;</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">205</span>];</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		n = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">char</span> a[<span class="number">205</span>] = &#123;<span class="string">&#x27;s&#x27;</span>&#125;, b[<span class="number">205</span>] = &#123;<span class="string">&#x27;1&#x27;</span>&#125;, c[<span class="number">205</span>] = &#123;<span class="string">&#x27;-&#x27;</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> d = <span class="number">0</span>, e = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span> || s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				a[d] = s[i];</span><br><span class="line">				d++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				b[e] = s[i];</span><br><span class="line">				e++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				c[f] = s[i];</span><br><span class="line">				f++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n%s\n&quot;</span>, a, b,c );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#1178 密码翻译</title>
    <url>/swustoj/1178/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密，简单的加密算法虽然不足以完全避免情报被破译，但仍然能防止情报被轻易的识别。我们给出一种最简的的加密方法，对给定的一个字符串，把其中从a-y，A-Y的字母用其后继字母替代，把z和Z用a和A替代，其他非字母字符不变，则可得到一个简单的加密字符串。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>多组测试数据；<br>每组数据输入一行，包含一个字符串(保证没有空格)，长度小于80个字符。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出每行字符串的加密字符串。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>Hello!Howareyou!</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>Ifmmp!Ipxbsfzpv!</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a))</span><br><span class="line">	&#123;</span><br><span class="line">		sum = <span class="built_in">strlen</span>(a);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; a[i] &lt; =<span class="string">&#x27;y&#x27;</span> || a[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; a[i] &lt;= <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">				a[i] = a[i] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(a[i] == <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">				a[i] = a[i] - <span class="number">25</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(a[i] == <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">				a[i] = a[i] - <span class="number">25</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>, a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#148 陶陶摘苹果</title>
    <url>/swustoj/148/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>陶陶家的院子里有一棵苹果树，每到秋天树上就会结出10个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个30厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。 现在已知10个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入包括两行数据。第一行包含10个100到200之间（包括100和200）的整数（以厘米为单位）分别表示10个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个100到120之间（包含100和120）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>100 200 150 140 129 134 167 198 200 111<br>110</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>5</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> one, two, three, four, five, six, seven, eight, nine, ten;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d %d %d %d %d %d&quot;</span>, &amp;one, &amp;two, &amp;three, &amp;four, &amp;five, &amp;six, &amp;seven, &amp;eight, &amp;nine, &amp;ten);</span><br><span class="line">    <span class="keyword">int</span> hand;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;hand);</span><br><span class="line">    hand += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(one &lt;= hand)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(two &lt;= hand)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(three &lt;= hand)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>(four &lt;= hand)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>(five &lt;= hand)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>(six &lt;= hand)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>(seven &lt;= hand)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(eight &lt;= hand)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>(nine &lt;= hand)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">if</span>(ten &lt;= hand)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#160 促销计算</title>
    <url>/swustoj/160/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>某百货公司为了促销，采用购物打折的优惠方法，每位顾客一次购物：在1000元以上者，按9.5折优惠；在2000以上者，按9折优惠；在3000以上者，按8.5折优惠；在5000以上者，按8折优惠；编写程序，购物款数，计算并输出优惠价。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>850<br>1230<br>5000<br>3560</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>discount=1,pay=850<br>discount=0.95,pay=1168.5<br>discount=0.8,pay=4000<br>discount=0.85,pay=3026</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a, dc, p;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;a);</span><br><span class="line">	<span class="keyword">if</span>(a &lt; <span class="number">1000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dc = <span class="number">1</span>, p = a*dc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a &lt; <span class="number">2000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dc = <span class="number">0.95</span>, p = a*dc;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a &lt; <span class="number">3000</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dc = <span class="number">0.9</span>, p = a*dc;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a &lt; <span class="number">5000</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					dc = <span class="number">0.85</span>, p = a*dc;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					dc = <span class="number">0.8</span>, p = a*dc;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;discount=%g,pay=%g\n&quot;</span>, dc, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#171 字符串的倒序</title>
    <url>/swustoj/171/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>设计函数，实现字符串的倒序输出。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>Tomorrow<br>Yesterday<br>Today<br>Tomorrowisantherday!<br>Debug\ee.exe<br>ee-MicrosoftVisualC++-[ee.cpp]</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>worromoT<br>yadretseY<br>yadoT<br>!yadrehtnasiworromoT<br>exe.ee\gubeD<br>]ppc.ee[-++ClausiVtfosorciM-ee</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		n=<span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#287 one + two = 3</title>
    <url>/swustoj/287/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>读入两个小于100的正整数A和B，计算A+B。需要注意的是：A和B的每一位数字由对应的英文单词给出。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>测试输入包含若干测试用例，每个测试用例占一行，格式为”A + B =”，相邻两字符串有一个空格间隔。当A和B同时为0时输入结束，相应的结果不要输出。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>对每个测试用例输出1行，即A+B的值。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>one + two =<br>three four + five six =<br>zero seven + eight nine =<br>zero + zero =</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>3<br>90<br>96</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num1</span><span class="params">(<span class="keyword">char</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;one&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;two&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;three&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;four&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;five&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;six&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;seven&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;eight&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;nine&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;zero&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num2</span><span class="params">(<span class="keyword">char</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;one&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;two&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;three&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;four&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;five&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;six&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;seven&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;eight&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;nine&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;zero&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>, sum1=<span class="number">0</span>, sum2=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">		sum1=num1(a);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;+&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sum1 = sum1*<span class="number">10</span> + num1(a);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">		sum2 = num2(a);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,<span class="string">&quot;=&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sum2 = sum2*<span class="number">10</span> + num2(a);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">		&#125;</span><br><span class="line">		sum = sum1 + sum2;</span><br><span class="line">		<span class="keyword">if</span>(sum == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#288 统计出现最多次的字母</title>
    <url>/swustoj/288/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个只有小写英文字母组成的字符串，串长为n。请你编写程序求出这个字符串中出现次数最多的字母。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入有两行：第一行是一个正整数n（ 1 &lt; n &lt; 100）表示字符串的长度。后面一行是一个长度为n的字符串（只由小写字母组成）。测试用例保证出现次数最多的字母只有一个。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出一行，仅输出出现次数最多的字母。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>acmcs</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>c</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, sum=<span class="number">0</span>, ll=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;a);</span><br><span class="line">		sum = a - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		b[sum]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b[i] &gt; ll)</span><br><span class="line">		&#123;</span><br><span class="line">			sum = i;</span><br><span class="line">			ll = b[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a = sum + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#299 平方和</title>
    <url>/swustoj/299/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>用递归的方法求 f(n) = 1 * 1 + 2 * 2 + 3 * 3 +……+ n * n</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入数字n</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出结果 f(n)</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>1<br>3</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1<br>14</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">  		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f(n<span class="number">-1</span>)+n*n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f(n));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#320 鸡兔同笼</title>
    <url>/swustoj/320/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>一个笼子里关了鸡和兔（鸡有2只脚，兔又4只脚，没有例外）。已知笼子里面脚的总数a，问笼子里面至少有多少只动物，至多有多少只动物？</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>多组测试数据。第一行是测试数据的组数n，后面跟着n行输入。每组测试数据占一行，每行包含一个正整数a(a &lt; 65535)。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出包含n行，每行对应一个输入，包含两个正整数，第一个是最少动物数，第二个是最多动物数，中间用一个空格分开。如果没有满足要求的答案，则输出两个0。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>2<br>3<br>20</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>0 0<br>5 10</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  i, a, t, max, min;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;a; i++)		</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">			<span class="keyword">if</span>(t%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0 0\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				max = t/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(t%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">				min = t/<span class="number">4</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					min = t/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, min, max);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#321 函数的递归调用</title>
    <url>/swustoj/321/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>阶乘(factorial)是基斯顿·卡曼(Christian Kramp, 1760 – 1826)于1808年发明的运算符号。 任何大于1的自然数n阶乘可以表示为以下形式： n!=n×(n-1)! 另外，数学家定义，0！=1，所以0！=1！ 你的任务是编写一个程序来计算一个给定数字n的阶乘n!（n&lt;14）</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入数据只有一行，即数字n的值，（n&lt;14)。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>要求输出n!的值</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>120</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, n;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#509 寝室扫地问题</title>
    <url>/swustoj/509/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>东六—B104寝室四人经常记不住该谁扫地,他们是这样安排的:从2007年9月1号（星期六）起,每天按床号循环扫地，但是星期一除外,因为每个星期一都要检查卫生,他们决定星期一是大扫除。1号床：侯波（B），2号床：袁雄(X)，3号床：唐建华(H)，4号床：姚平(P)。9月1号就从1号床，侯波开始。请你编写一个程序帮他们解决寝室扫地问题。（不考虑节假日等其它因素）</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入一个日期，包括年(2007~2010)、月、日（用一个空格格开）</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出轮到哪位同学扫地(输出该同学姓名后的代号，时间是星期一时候输出ALL)。一个输出占一行。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>2007 9 1<br>2007 9 3<br>2009 3 1</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>B<br>ALL<br>X</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">12</span>]=&#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> year, month, day;</span><br><span class="line">	<span class="keyword">int</span> i, sum;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;year, &amp;month, &amp;day) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;month<span class="number">-1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			day += a[i];</span><br><span class="line">	    &#125;</span><br><span class="line">		day = day + (year<span class="number">-2007</span>) * <span class="number">365</span> - <span class="number">243</span>;</span><br><span class="line">		<span class="keyword">if</span>((year == <span class="number">2008</span> &amp;&amp; month &gt; <span class="number">2</span>) || year &gt; <span class="number">2008</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			day++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(day%<span class="number">7</span> == <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ALL\n&quot;</span>);</span><br><span class="line">		 	<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sum = (day - day/<span class="number">7</span>);</span><br><span class="line">		<span class="keyword">if</span>(day%<span class="number">7</span> &gt;= <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		 	sum--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span>(sum % <span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		 	<span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">printf</span>(<span class="string">&quot;B\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		 	<span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">printf</span>(<span class="string">&quot;X\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		 	<span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">printf</span>(<span class="string">&quot;H\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		 	<span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">&quot;P\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#563 String</title>
    <url>/swustoj/563/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>将下面的字符串中的大小写进行转换．</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入一行字符串．</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>将其中的大写转换为小写，小写转换为大写．</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>ABCd</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>abcD</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		n = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, s[i]+<span class="number">32</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, s[i]<span class="number">-32</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#580 The World Population Explosion</title>
    <url>/swustoj/580/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>In the past, when population grew, there was unexplored territory to inhabit. But now, almost all the habitable land has been explored. The world’s population may reach 8.7 billion in 2033. It is clear that world population is a serious issue that needs careful attention. Human beings are unique to solve problems through cultural evolution. Facing the world population explosion in the near future, we must carry out the birth control program in order to save the mankind and save the world. And now we have the population amount of some country of the world in last year and this year. your task is to differ the countries whose population is changed from the data below and sort them in descending order and return the changing value and names of those countries whose population amount are not changed as well.</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>The input consists of only one test case, followed by 4 lines, the first line is a integer N indicating the amount of the countries, and then input last year’s and this year’s population amount of every country in the last two lines before the names of the countries is inputted in the second line.</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>You should output the countries firstly whose population are changed followed by the rest of those whose population are unchanged. If the changes are the same between two countries, lexicographic order should be used in your code.</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>7<br>USA CHINA JAPAN KOREA CUBA ARGENTINA PERU<br>100 200 150 50 9 2 22<br>120 240 140 10 9 2 12</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>40 CHINA<br>20 USA<br>-10 JAPAN<br>-10 PERU<br>-40 KOREA<br>0 ARGENTINA<br>0 CUBA</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">WP</span> <span class="title">country</span>[1000];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">WP</span> <span class="title">t</span>;</span></span><br><span class="line">    <span class="keyword">int</span> n, i, j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, country[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;country[i].a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;country[i].b);</span><br><span class="line">        country[i].c = country[i].b-country[i].a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(j=i; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(country[i].c &lt; country[j].c)</span><br><span class="line">            &#123;</span><br><span class="line">                t = country[i];</span><br><span class="line">                country[i] = country[j];</span><br><span class="line">                country[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(country[i].c == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t = country[i];</span><br><span class="line">                country[i] = country[j];</span><br><span class="line">                country[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(country[i].c == country[j].c &amp;&amp; <span class="built_in">strcmp</span>(country[i].name,country[j].name) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t = country[i];</span><br><span class="line">                country[i] = country[j];</span><br><span class="line">                country[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, country[i].c, country[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#613 数字转换成字符</title>
    <url>/swustoj/613/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>本题目非常简单，请编写一个程序实现以下功能： １、输出整型和字符型在内存中所占的字节数； ２、输入两个数字，输出其相对应的字符。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入两个整型数字（a,b）.</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出有两行 第一行输出整型和字符在内存中所占的字节数，<br>第二行输出两个整数（输入的两个整数）所对应的字符。<br>详见下面的Sample Input和Sample Output。<br>每输出的两个数字或字符之间用一个空格隔开</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>80 80<br>97 98</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>4 1<br>P P<br>4 1<br>a b</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1, num2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %c\n&quot;</span>, num1, num2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#619 蟠桃记</title>
    <url>/swustoj/619/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>喜欢西游记的同学肯定都知道悟空偷吃蟠桃的故事，你们一定都觉得这猴子太闹腾了，其实你们是有所不知：悟空是在研究一个数学问题！ 什么问题？他研究的问题是蟠桃一共有多少个！ 不过，到最后，他还是没能解决这个难题，呵呵^-^ 当时的情况是这样的： 第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入数据有多组，每组占一行，包含一个正整数n（1 &lt; n &lt; 30），表示只剩下一个桃子的时候是在第n天发生的。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>对于每组输入数据，输出第一天开始吃的时候桃子的总数，每个测试实例占一行。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>2<br>4</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>4<br>22</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> (f(n<span class="number">-1</span>)+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f(n));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#69 偷菜时间表</title>
    <url>/swustoj/69/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>随着“开心农场”等娱乐游戏风靡互联网，“偷菜”遂瞬间蹿红网络，席卷网民生活。于是，“你‘偷’了吗”便成为大家见面的招呼语。很快，数百万都市白领成为“偷菜”队伍中的主力军，每天在“偷”与防“偷”中乐此不疲，甚至定闹钟半夜起床“偷”菜。根据“农作物”生长规律而变化制定偷菜时间表。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>假设当前时间为13：15，第一行输入作物种类数n,从第二行开始输入n 种作物成熟需要的时间，格式为: Hour, Minute。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>依次输出n 种作物成熟时间，每行输出一个</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>3<br>0:30<br>1:10<br>12:50</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>13:45<br>14:25<br>2:5</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m[<span class="number">60</span>], h[<span class="number">60</span>];</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>, &amp;h[i], &amp;a, &amp;m[i]);</span><br><span class="line">		<span class="keyword">if</span>((m[i]+<span class="number">15</span>) &gt;= <span class="number">60</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			m[i] = m[i] + <span class="number">15</span> - <span class="number">60</span>;</span><br><span class="line">			h[i]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			m[i] = m[i] + <span class="number">15</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((h[i]+<span class="number">13</span>) &gt;= <span class="number">24</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			h[i] = h[i] + <span class="number">13</span> - <span class="number">24</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			h[i] = h[i] + <span class="number">13</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, h[i] , m[i]);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#941 有序顺序表的合并操作的实现</title>
    <url>/swustoj/941/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>已知两非递减的顺序线性表，要求合并成一个新的非递减顺序线性表。(测试数据为整型)</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入包含四行，第一行为自然数n，表示第一个非递减顺序线性表的长度;<br>第二行为n个自然数构成的非递减顺序线性表;<br>第三行为自然数m，表示第二个非递减顺序线性表的长度;<br>第四行为m个自然数构成的非递减顺序线性表。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出：用一行输出合并后的非递减顺序线性表，各数之间用一个空格隔开。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>2<br>1 3<br>3<br>2 3 6</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1 2 3 3 6</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i <span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr1[i];</span><br><span class="line">        v1.push_back(arr1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr2[i];</span><br><span class="line">        v2.push_back(arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = v2.begin(); iter != v2.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.push_back(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v1.begin(), v1.end());</span><br><span class="line">    iter = v1.begin();</span><br><span class="line">    <span class="keyword">for</span>(iter = v1.begin(); iter != v1.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#942 逆置顺序表</title>
    <url>/swustoj/942/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>建立长度为 n 的顺序表，然后将表中的数据元素逆置，即若表中原来的数据元素序列（ a0，a1，a2，… ，an），则逆置后的数据元素序列为（an，an-1，an-2，… ，a1，a0）。（数据类型为字符型）</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为顺序表的长度n；第二行为顺序表中的数据元素.</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出为逆置后的顺序表.</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>7<br>ABCDEFG</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>G F E D C B A</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // 调用顺序表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 加该头文件即使用函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> arr1[<span class="number">1000</span>]; <span class="comment">// 顺序表</span></span><br><span class="line">	<span class="keyword">int</span> n; <span class="comment">// 顺序表的长度</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v1; <span class="comment">// 指定 char 类型顺序表到 v1</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n; <span class="comment">// 输入 n</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr1[i]; <span class="comment">// 输入数组元素</span></span><br><span class="line">		v1.push_back(arr1[i]); <span class="comment">// push_back 将当前元素按顺序放后面</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator iter; <span class="comment">// 申请迭代器 iter 指向数组中某个元素的地址</span></span><br><span class="line">	reverse(v1.begin(), v1.end()); <span class="comment">// reverse 表示反转，将 v1 的开头结尾对调实现逆序</span></span><br><span class="line">	<span class="keyword">for</span>(iter = v1.begin(); iter != v1.end(); iter++) <span class="comment">// 遍历访问 iter 的地址</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 遍历输出 iter 地址里的元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#943 顺序表插入操作的实现</title>
    <url>/swustoj/943/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>建立长度为n的顺序表，在指定的数据元素item之前插入数据元素data。如果指定的数据元素item不存在，则将data插入到顺序表的尾端。（数据类型为整型）</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为顺序表的长度n；<br>第二行为顺序表中的数据元素；<br>第三行为指定的数据元素item；<br>第四行为要插入的数据元素data；</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出结果为顺序表中的数据元素。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>10<br>10 20 30 40 50 60 70 80 90 100<br>50<br>55</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>10 20 30 40 55 50 60 70 80 90 100</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt; // 使用顺序表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; // 使用函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">		List.push_back(arr[i]); <span class="comment">// 将数组元素放入顺序表</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> date;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; date;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter; <span class="comment">// 迭代器</span></span><br><span class="line">	iter = List.begin();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; *iter!=m &amp;&amp; iter!=List.end(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		iter++;</span><br><span class="line">	&#125;</span><br><span class="line">	List.insert(iter,date); <span class="comment">// 放入date在List后</span></span><br><span class="line">	iter = List.begin();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; iter != List.end(); iter++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#952 单链表的插入操作的实现</title>
    <url>/swustoj/952/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>建立长度为 n 的单链表，在第 i 个结点之前插入数据元素 data。</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为自然数n，表示链式线性表的长度；<br> 第二行为n个自然数表示链式线性表各元素值；<br>第三行为指定插入的位置i；第四行为待插入数据元素data。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>指定插入位置合法时候，输出插入元素后的链式线性表的所有元素，元素之间用一个空格隔开。输入不合法，输出”error!”。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>1 2 3 4 5<br>3<br>6</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1 2 6 3 4 5</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">        L.push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> date;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; date;</span><br><span class="line">    <span class="keyword">if</span>(m &gt; L.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error!&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    iter = L.begin();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    L.insert(iter, date);</span><br><span class="line">    iter = L.begin();</span><br><span class="line">    <span class="keyword">for</span>(iter = L.begin(); iter != L.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#953 单链表的删除操作的实现</title>
    <url>/swustoj/953/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>建立长度为 n 的单链表，删除第 i 个结点之前的结点。</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为自然数 n，表示链式线性表的长度；<br>第二行为 n 个自然数表示链式线性表各元素值；<br>第三行为指定的删除参数 i 。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>指定删除位置合法时候，输出删除元素后的链式线性表的所有元素，元素之间用一个空格隔开。<br>输入不合法，输出”error!”。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>5<br>1 2 3 4 5<br>3</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1 3 4 5</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">		List.push_back(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m; <span class="comment">// 输入要删除的参数</span></span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">	iter = List.begin();</span><br><span class="line">	<span class="keyword">if</span> (m &gt; List.size() || m &lt;= <span class="number">1</span>) <span class="comment">// 输入不合法</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error!&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i!=m &amp;&amp; i&lt;List.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		iter++;</span><br><span class="line">	&#125;</span><br><span class="line">	iter--; <span class="comment">// 定位前一个节点</span></span><br><span class="line">	List.erase(iter); <span class="comment">// 删除前一个节点</span></span><br><span class="line">	iter = List.begin();</span><br><span class="line">	<span class="keyword">for</span> (iter = List.begin(); iter != List.end(); iter++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#954 单链表的链接</title>
    <url>/swustoj/954/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>建立长度为 n 的单链表 A 和长度为 m 的单链表 B 。编程实现将 B 表链接在 A 表的尾端，形成一个单链表 A 。数据类型指定为字符型。</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为A表的长度n；<br>第二行为A表中的数据元素;<br>第三行为B表的长度m；<br>第四行为B表中的数据元素。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出为链接好后的A表中的所有数据元素。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>4<br>A B C D<br>6<br>1 2 3 4 5 6</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>A B C D 1 2 3 4 5 6</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; List1;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; List2;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">char</span> arr1[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">char</span> arr2[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr1[i];</span><br><span class="line">        List1.push_back(arr1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr2[i];</span><br><span class="line">        List2.push_back(arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = List2.begin(); iter != List2.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        List1.push_back(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(iter = List1.begin(); iter != List1.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#955 单链表上查找算法的实现</title>
    <url>/swustoj/955/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>建立一个长度为 n 的带头结点的单链表，在该表中寻找第 i 个结点，若找到，则输出 ok ，否则输出 error 。处理数据类型为整型。</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为链表的长度n；<br>第二行为链表中的数据元素；<br>第三行为要找的结点i。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>找到就输出ok，没找到就输出error。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>10<br>1 2 3 4 5 6 7 8 9 10<br>5</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>ok</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="comment">// 要找的节点</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">        List.push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    iter = List.begin();</span><br><span class="line">    <span class="keyword">if</span>(m&gt;List.size() || m&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i!=m &amp;&amp; i&lt;List.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#956 约瑟夫问题的实现</title>
    <url>/swustoj/956/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>n个人围成一个圈，每个人分别标注为1、2、…、n，要求从1号从1开始报数，报到k的人出圈，接着下一个人又从1开始报数，如此循环，直到只剩最后一个人时，该人即为胜利者。例如当n=10,k=4时，依次出列的人分别为4、8、2、7、3、10，9、1、6、5，则5号位置的人为胜利者。给定n个人，请你编程计算出最后胜利者标号数。（要求用单循环链表完成。）</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为人数n;<br>第二行为报数k。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出最后胜利者的标号数。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>10<br>4</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>5</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">int</span> n, x;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(Q.size() == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=x; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == x)</span><br><span class="line">			&#123;</span><br><span class="line">				Q.pop();</span><br><span class="line">				i = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(Q.size() == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> temp = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			Q.push(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Q.front();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#957 逆置单链表</title>
    <url>/swustoj/957/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>建立长度为 n 的单链表，然后将其数据元素逆置，即第1个元素变为最后一个元素，第2个元素变为倒数第2个元素，以此类推，最后一个元素变为第1个元素。（处理的数据类型为字符型。必须使用链表完成。）</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为链表长度n；<br>第二行为链表中的n个数据元素的值。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>逆置后的原始的值。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>10<br>ABCDEFGHIJ</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>J I H G F E D C B A</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; List;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">        List.push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator iter;</span><br><span class="line">    reverse(List.begin(), List.end());</span><br><span class="line">    <span class="keyword">for</span>(iter = List.begin(); iter != List.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#960 双向链表的操作问题</title>
    <url>/swustoj/960/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>建立一个长度为 n 的带头结点的双向链表，使得该链表中的数据元素递增有序排列。（必须使用双向链表完成，数据类型为整型。）</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行：双向表的长度；<br>第二行：链表中的数据元素。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出双向链表中的数据元素的值。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>10<br>2 4 6 3 5 8 10 21 12 9</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>2 3 4 5 6 8 9 10 12 21</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">        List.push_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    List.sort();</span><br><span class="line">    <span class="keyword">for</span>(iter = List.begin(); iter != List.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#961 进制转换问题</title>
    <url>/swustoj/961/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>建立顺序栈或链栈，编写程序实现十进制数到二进制数的转换。</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入只有一行，就是十进制整数。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>转换后的二进制数。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>10</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1010</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        List.push_front(m%<span class="number">2</span>);</span><br><span class="line">        m = m/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = List.begin(); iter != List.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#962 括号匹配问题</title>
    <url>/swustoj/962/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>假设表达式中允许包含两种括号:圆括号和方括号。编写一个算法判断表达式中的括号是否正确配对。</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>由括号构成的字符串，包含”（“、”）“、”[“和”]“。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>如果匹配输出YES，否则输出NO。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>[ ( [ ] [ ] ( ) ) ]</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>YES</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; arr[i]!= <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (st.empty())</span><br><span class="line">			st.push(arr[i]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((st.top() == <span class="string">&#x27;[&#x27;</span>&amp;&amp;arr[i]==<span class="string">&#x27;]&#x27;</span>) || ( st.top() == <span class="string">&#x27;(&#x27;</span>&amp;&amp;arr[i]==<span class="string">&#x27;)&#x27;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			st.push(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (st.empty())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#963 小偷的背包</title>
    <url>/swustoj/963/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>设有一个背包可以放入的物品重量为S，现有n件物品，重量分别是w1，w2，w3，…，wn。问能否从这n件物品中选择若干件放入背包中，使得放入的重量之和正好为S。如果有满足条件的选择，则此背包有解，否则此背包问题无解。</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为物品重量S（整数）；<br>第二行为物品数量n，<br>第三行为n件物品的重量的序列。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>有解就输出”yes!“，没有解就输出”no!“。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>20<br>5<br>1 3 5 7 9</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>yes!</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> n, <span class="keyword">int</span> weigth[<span class="number">1000</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S != <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(S == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// return 1 后退出函数</span></span><br><span class="line">	<span class="keyword">if</span>(test(S - weigth[n<span class="number">-1</span>], n - <span class="number">1</span>, weigth)) <span class="comment">// 上面均不成立，判断下一个数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// if(1) return 1 else return 0</span></span><br><span class="line">	test(S, n - <span class="number">1</span>, weigth); <span class="comment">// 上一步 return 0 就再次判断下一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> S;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> weigth[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; S;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; weigth[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(test(S, n, weigth))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yes!&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no!&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#964 数细胞</title>
    <url>/swustoj/964/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一矩形阵列由数字0到9组成，数字1到9代表细胞,细胞的定义为沿细胞数字上下左右还是细胞数字则为同一细胞,求给定矩形阵列的细胞个数。编程需要用到的队列及其相关函数已经实现，你只需要完成count函数以及主函数即可。</p>
<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 50000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pos</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">se</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	pos data[max];</span><br><span class="line">	<span class="keyword">int</span> front,rear;</span><br><span class="line">&#125; Sequeue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Sequeue *&amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q=(Sequeue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Sequeue));</span><br><span class="line">	Q-&gt;front=<span class="number">-1</span>;</span><br><span class="line">	Q-&gt;rear=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Sequeue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;rear==Q-&gt;front)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertsequeue</span><span class="params">(Sequeue *&amp;Q,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%max==Q-&gt;front)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;队列已满！&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%max;</span><br><span class="line">	Q-&gt;data[Q-&gt;rear].x=i;</span><br><span class="line">	Q-&gt;data[Q-&gt;rear].y=j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delsequeue</span><span class="params">(Sequeue *&amp;Q,<span class="keyword">int</span> &amp;i,<span class="keyword">int</span> &amp;j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;rear==Q-&gt;front)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;队列已空！&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%max;</span><br><span class="line">	i=Q-&gt;data[Q-&gt;front].x;</span><br><span class="line">	j=Q-&gt;data[Q-&gt;front].y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> a[<span class="number">50</span>][<span class="number">50</span>],<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> test[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">int</span> i,j, m,n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;test[i][j];</span><br><span class="line">	change(test,m,n);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;count(test,m,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行输入两个整数，分别代表矩阵的行和列 输入m*n的矩阵，由数字0到9组成。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>细胞个数。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>4 10<br>1 2 3 4 5 1 1 1 6 7<br>1 0 3 4 5 6 1 5 1 0<br>2 0 4 5 6 6 1 6 7 1<br>0 0 6 0 6 6 1 0 8 9</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">100</span>], <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((i + <span class="number">1</span>  &lt; m ? arr[i + <span class="number">1</span>][j] : <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i + <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">		find(i + <span class="number">1</span>, j, arr, Q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((i<span class="number">-1</span> &gt;= <span class="number">0</span> ? arr[i <span class="number">-1</span>][j] : <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i<span class="number">-1</span>][j] = <span class="number">0</span>;</span><br><span class="line">		find(i - <span class="number">1</span>, j, arr, Q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((j+<span class="number">1</span>&lt; n ? arr[i][j+<span class="number">1</span>] : <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i][j+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		find(i , j+<span class="number">1</span>, arr, Q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((j<span class="number">-1</span>&gt;=<span class="number">0</span> ? arr[i][j<span class="number">-1</span>] : <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i][j<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">		find(i, j<span class="number">-1</span>, arr, Q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (((j - <span class="number">1</span> &gt;= <span class="number">0</span> ? arr[i][j - <span class="number">1</span>] : <span class="number">0</span>) == <span class="number">0</span>) &amp;&amp; ((i + <span class="number">1</span> &lt; m ? arr[i + <span class="number">1</span>][j] : <span class="number">0</span>) == <span class="number">0</span>) &amp;&amp; ((j + <span class="number">1</span> &lt; n ? arr[i][j + <span class="number">1</span>] : <span class="number">0</span>) == <span class="number">0</span>) &amp;&amp; ((i - <span class="number">1</span> &gt;= <span class="number">0</span> ? arr[i - <span class="number">1</span>][j] : <span class="number">0</span>) == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				arr[i][j] = <span class="number">0</span>;</span><br><span class="line">				find(i, j, arr, Q);</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#965 循环队列</title>
    <url>/swustoj/965/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>根据给定的空间构造顺序循环队列，规定队满处理方法为少用一个元素空间。例如，给定5个元素空间构造循环队列，则只能存放4个元素。试根据入队及出队操作判断队列最后的元素存放情况，并输出最后队列中的元素值，即完成给定入队及出列操作后一次性全部出队的元素值。要求采用顺序队列完成，少用一个存储空间的方法区分队列的空和满。</p>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入的第一行为一个自然数n，表示要求构造的顺序循环队列空间数。<br> 第二行为操作次 k，接下来k行为出队入队操作，每行各代表一次操作。<br> 入队用in表示，出队用out表示，如果是入队，则in隔一空格后为一整数，表示入队元素值。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出完成所有入队出队操作后，一次性出队元素。<br>用一个空格隔开。<br>可以假定队在完成所有操作后不为空。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>4<br>7<br>in 1<br>in 2<br>in 5<br>in 6<br>out<br>out<br>in 8</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>5 8</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> choose;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; choose;</span><br><span class="line">		<span class="keyword">if</span> (choose == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> a;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">			<span class="keyword">if</span> (Q.size() &gt;= m<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			Q.push(a);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (choose == <span class="string">&quot;out&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!Q.empty())</span><br><span class="line">			Q.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Q.front() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		Q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#971 统计利用先序遍历创建的二叉树的深度</title>
    <url>/swustoj/971/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并计算该二叉树的深度。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再统计创建完成的二叉树的深度（使用二叉树的后序遍历算法）。需要注意输入数据序列中的”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入为先序遍历二叉树结点序列。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>对应的二叉树的深度。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>A##<br>ABC####<br>AB##C##<br>ABCD###E#F##G##<br>A##B##</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1<br>3<br>2<br>4<br>1</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getleft</span><span class="params">(TreeNode * p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		leftnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getright</span><span class="params">(TreeNode *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rightnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode(<span class="keyword">char</span> a) &#123; data = a; leftnode = <span class="literal">NULL</span>; rightnode = <span class="literal">NULL</span>; &#125;;</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	TreeNode *leftnode;</span><br><span class="line">	TreeNode *rightnode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(TreeNode* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">preoder</span><span class="params">()</span></span>;											<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">preoder</span><span class="params">(TreeNode* current,<span class="keyword">int</span> h1,<span class="keyword">int</span> h2)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span></span>;</span><br><span class="line">	TreeNode * root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarytree::preoder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h1=<span class="number">1</span>, h2=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> preoder(root,h1,h2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarytree::preoder</span><span class="params">(TreeNode* current,<span class="keyword">int</span> h1,<span class="keyword">int</span> h2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (current)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (h1 &gt;= h2&amp;&amp;h1 &gt; h)</span><br><span class="line">			h = h1;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (h2 &gt;= h1&amp;&amp;h2 &gt; h)</span><br><span class="line">			h = h2;</span><br><span class="line">		h1++;</span><br><span class="line">		preoder(current-&gt;leftnode,h1,h2);</span><br><span class="line">		h2++;</span><br><span class="line">		preoder(current-&gt;rightnode,h2,h2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span>		<span class="comment">//注意这里的是引用地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> TreeNode(arr[i]);</span><br><span class="line">		i++;</span><br><span class="line">		preinsert(current-&gt;leftnode, arr);</span><br><span class="line">		preinsert(current-&gt;rightnode, arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	binarytree Tree;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	Tree.preinsert(Tree.root, arr);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; Tree.preoder();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#966 打印杨辉三角形</title>
    <url>/swustoj/966/</url>
    <content><![CDATA[<p>👇</p>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>杨辉三角形具有如下特征：</p>
<p>1、每行数字左右对称，由1开始逐渐变大，然后变小，回到1。 </p>
<p>2、第n行的数字个数为n个。 </p>
<p>3、第n行数字和为2^(n－1)。 </p>
<p>4、每个数字等于上一行的左右两个数字之和。可用此性质写出整个帕斯卡三角形。  </p>
<p>5、将第2n+1行第1个数，跟第2n+2行第3个数、第2n+3行第5个数……连成一线，这些数的和是第2n个斐波那契数。将第2n行第2个数，跟第2n+1行第4个数、第2n+2行第6个数……这些数之和是第2n-1个斐波那契数。 </p>
<p>6、第n行的第1个数为1，第二个数为1×(n-1)，第三个数为1×(n-1)×（n-2）/2，第四个数&gt; 为1×(n-1)×（n-2）/2×（n-3）/3…依此类推。</p>
<p>例如7阶杨辉三角形如下：</p>
<p>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>1 5 10 10 5 1<br>1 6 15 20 15 6 1<br>要求：利用循环队列，编程实现打印杨辉三角形。（n在0-12之间取值）</p>
</blockquote>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入要打印的杨辉三角形的阶n。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>打印出n阶杨辉三角形。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>7</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1<br>1 5 10 10 5 1<br>1 6 15 20 15 6 1</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;				<span class="comment">//要打印的杨辉三角的阶数</span></span><br><span class="line">	Q.push(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; Q.front();</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Q.push(<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span> (i != <span class="number">1</span>)</span><br><span class="line">				&#123;	</span><br><span class="line">					Q.pop();	</span><br><span class="line">					Q.push(<span class="number">1</span> + Q.front());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (j == i)</span><br><span class="line">			&#123;</span><br><span class="line">				Q.pop();</span><br><span class="line">				Q.push(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> x = Q.front();</span><br><span class="line">				Q.pop();</span><br><span class="line">				Q.push(x + Q.front());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#972 统计利用先序遍历创建的二叉树的宽度</title>
    <url>/swustoj/972/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并计算该二叉树的宽度。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再统计创建完成的二叉树的宽度（是指二叉树每层节点数的最大值）。需要注意输入数据序列中”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入为接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树）。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出该用例对应的二叉树的宽度。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>A##<br>ABC####<br>AB##C##<br>ABCD###EF##G###<br>A##B##</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>1<br>1<br>2<br>3<br>1</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getleft</span><span class="params">(TreeNode * p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		leftnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getright</span><span class="params">(TreeNode *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rightnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode(<span class="keyword">char</span> a) &#123; data = a; leftnode = <span class="literal">NULL</span>; rightnode = <span class="literal">NULL</span>; &#125;;</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	TreeNode *leftnode;</span><br><span class="line">	TreeNode *rightnode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(TreeNode* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">leveloder</span><span class="params">()</span></span>;											<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">leveloder</span><span class="params">(TreeNode* current,<span class="built_in">queue</span>&lt;TreeNode*&gt;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span></span>;</span><br><span class="line">	TreeNode * root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarytree::leveloder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;TreeNode*&gt; Q;</span><br><span class="line">	Q.push(root);</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	ret = leveloder(root, Q);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">0</span>&amp;&amp;root)</span><br><span class="line">		ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarytree::leveloder</span><span class="params">(TreeNode* current,<span class="built_in">queue</span>&lt;TreeNode*&gt; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TreeNode* temp = Q.front();</span><br><span class="line">	Q.pop();</span><br><span class="line">	<span class="keyword">if</span>(temp-&gt;leftnode) Q.push(temp-&gt;leftnode);</span><br><span class="line">	<span class="keyword">if</span>(temp-&gt;rightnode) Q.push(temp-&gt;rightnode);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(temp-&gt;leftnode) leveloder(temp-&gt;leftnode, Q);</span><br><span class="line">	<span class="keyword">if</span>(temp-&gt;rightnode) leveloder(temp-&gt;rightnode, Q);</span><br><span class="line">	Count = Q.size() &gt; Count ? Q.size() : Count;</span><br><span class="line">	<span class="keyword">return</span> Count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span>		<span class="comment">//注意这里的是引用地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> TreeNode(arr[i]);</span><br><span class="line">		i++;</span><br><span class="line">		preinsert(current-&gt;leftnode, arr);</span><br><span class="line">		preinsert(current-&gt;rightnode, arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	binarytree Tree;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	Tree.preinsert(Tree.root, arr);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; Tree.leveloder();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#973 统计利用先序遍历创建的二叉树叶结点的个数</title>
    <url>/swustoj/973/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并计算该二叉树叶结点的个数。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再统计创建完成的二叉树叶结点的个数。需要注意输入数据序列中的”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树）。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出对应的二叉树叶结点的个数。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>#<br>A##<br>ABC####<br>AB##C##<br>ABCD###EF##G###<br>A##B##<br>#A</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>0<br>1<br>1<br>2<br>3<br>1<br>0</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getleft</span><span class="params">(TreeNode * p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		leftnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getright</span><span class="params">(TreeNode *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rightnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode(<span class="keyword">char</span> a) &#123; data = a; leftnode = <span class="literal">NULL</span>; rightnode = <span class="literal">NULL</span>; &#125;;</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	TreeNode *leftnode;</span><br><span class="line">	TreeNode *rightnode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(TreeNode* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">leveloder</span><span class="params">()</span></span>;											<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">leveloder</span><span class="params">(TreeNode* current)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span></span>;</span><br><span class="line">	TreeNode * root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::leveloder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root)</span><br><span class="line">	leveloder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::leveloder</span><span class="params">(TreeNode* current)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (current&amp;&amp;current-&gt;leftnode==<span class="literal">NULL</span>&amp;&amp;current-&gt;rightnode==<span class="literal">NULL</span>)Count++;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;leftnode) leveloder(current-&gt;leftnode);</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;rightnode) leveloder(current-&gt;rightnode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span>		<span class="comment">//注意这里的是引用地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> TreeNode(arr[i]);</span><br><span class="line">		i++;</span><br><span class="line">		preinsert(current-&gt;leftnode, arr);</span><br><span class="line">		preinsert(current-&gt;rightnode, arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	binarytree Tree;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	Tree.preinsert(Tree.root, arr);</span><br><span class="line">	Tree.leveloder();</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Count;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#975 统计利用先序遍历创建的二叉树的度为2的结点个数</title>
    <url>/swustoj/975/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并计算该二叉树度为2结点的个数。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再统计创建完成的二叉树度为2的结点个数。需要注意输入数据序列中的”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树）。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出该用例对应的二叉树度为2的结点个数。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>#<br>A##<br>ABC####<br>AB##C##<br>ABCD###EF##G##H##<br>A##B##<br>#A</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>0<br>0<br>0<br>1<br>3<br>0<br>0</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getleft</span><span class="params">(TreeNode * p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		leftnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getright</span><span class="params">(TreeNode *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rightnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode(<span class="keyword">char</span> a) &#123; data = a; leftnode = <span class="literal">NULL</span>; rightnode = <span class="literal">NULL</span>; &#125;;</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	TreeNode *leftnode;</span><br><span class="line">	TreeNode *rightnode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(TreeNode* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">leveloder</span><span class="params">()</span></span>;											<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">leveloder</span><span class="params">(TreeNode* current)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span></span>;</span><br><span class="line">	TreeNode * root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::leveloder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root)</span><br><span class="line">	leveloder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::leveloder</span><span class="params">(TreeNode* current)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (current&amp;&amp;current-&gt;leftnode&amp;&amp;current-&gt;rightnode)Count++;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;leftnode) leveloder(current-&gt;leftnode);</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;rightnode) leveloder(current-&gt;rightnode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span>		<span class="comment">//注意这里的是引用地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> TreeNode(arr[i]);</span><br><span class="line">		i++;</span><br><span class="line">		preinsert(current-&gt;leftnode, arr);</span><br><span class="line">		preinsert(current-&gt;rightnode, arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	binarytree Tree;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	Tree.preinsert(Tree.root, arr);</span><br><span class="line">	Tree.leveloder();</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Count;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#976 统计利用先序遍历创建的二叉树的度为1的结点个数</title>
    <url>/swustoj/976/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并计算该二叉树度为1结点的个数。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再统计创建完成的二叉树度为1的结点个数。需要注意输入数据序列中的”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入为接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树）。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>每个用例用一行输出该用例对应的二叉树度为1的结点个数。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>#<br>A##<br>ABC####<br>AB##C##<br>ABCD###EF##G###<br>A##B##<br>#A</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>0<br>0<br>2<br>0<br>2<br>0<br>0</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getleft</span><span class="params">(TreeNode * p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		leftnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getright</span><span class="params">(TreeNode *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rightnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode(<span class="keyword">char</span> a) &#123; data = a; leftnode = <span class="literal">NULL</span>; rightnode = <span class="literal">NULL</span>; &#125;;</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	TreeNode *leftnode;</span><br><span class="line">	TreeNode *rightnode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(TreeNode* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">leveloder</span><span class="params">()</span></span>;											<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">leveloder</span><span class="params">(TreeNode* current)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span></span>;</span><br><span class="line">	TreeNode * root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::leveloder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root)</span><br><span class="line">	leveloder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::leveloder</span><span class="params">(TreeNode* current)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((current&amp;&amp;current-&gt;leftnode == <span class="literal">NULL</span>&amp;&amp;current-&gt;rightnode) || (current&amp;&amp;current-&gt;leftnode&amp;&amp;current-&gt;rightnode==<span class="literal">NULL</span>))</span><br><span class="line">		Count++;</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;leftnode) leveloder(current-&gt;leftnode);</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;rightnode) leveloder(current-&gt;rightnode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span>		<span class="comment">//注意这里的是引用地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> TreeNode(arr[i]);</span><br><span class="line">		i++;</span><br><span class="line">		preinsert(current-&gt;leftnode, arr);</span><br><span class="line">		preinsert(current-&gt;rightnode, arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	binarytree Tree;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	Tree.preinsert(Tree.root, arr);</span><br><span class="line">	Tree.leveloder();</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Count;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#977 统计利用先序遍历创建的二叉树中的空链域个数</title>
    <url>/swustoj/977/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并计算该二叉树中的空链域个数。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再统计创建完成的二叉树中的空链域个数。需要注意输入数据序列中的”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入为接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树）。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出该用例对应的二叉树中的空链域个数。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>A##<br>ABC####<br>AB##C##<br>ABCD###EF##G###<br>A##B##<br>#A</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>2<br>4<br>4<br>8<br>2<br>1</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getleft</span><span class="params">(TreeNode * p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		leftnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getright</span><span class="params">(TreeNode *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rightnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode(<span class="keyword">char</span> a) &#123; data = a; leftnode = <span class="literal">NULL</span>; rightnode = <span class="literal">NULL</span>; &#125;;</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	TreeNode *leftnode;</span><br><span class="line">	TreeNode *rightnode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(TreeNode* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">leveloder</span><span class="params">()</span></span>;											<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">leveloder</span><span class="params">(TreeNode* current)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span></span>;</span><br><span class="line">	TreeNode * root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::leveloder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root)</span><br><span class="line">	leveloder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::leveloder</span><span class="params">(TreeNode* current)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;leftnode == <span class="literal">NULL</span>&amp;&amp;current-&gt;rightnode == <span class="literal">NULL</span>)</span><br><span class="line">		Count += <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;leftnode == <span class="literal">NULL</span> || current-&gt;rightnode == <span class="literal">NULL</span>)</span><br><span class="line">		Count++;</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;leftnode) leveloder(current-&gt;leftnode);</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;rightnode) leveloder(current-&gt;rightnode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span>		<span class="comment">//注意这里的是引用地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> TreeNode(arr[i]);</span><br><span class="line">		i++;</span><br><span class="line">		preinsert(current-&gt;leftnode, arr);</span><br><span class="line">		preinsert(current-&gt;rightnode, arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	binarytree Tree;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	Tree.preinsert(Tree.root, arr);</span><br><span class="line">	Tree.leveloder();</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Count;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#978 输出利用先序遍历创建的二叉树的中序遍历序列</title>
    <url>/swustoj/978/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并输出该二叉树的中序遍历序列。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再输出创建完成的二叉树的中序遍历序列。需要注意输入数据序列中的”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入为接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树）。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>对应的二叉树的中序遍历序列。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>A##<br>ABC####<br>AB##C##<br>ABCD###EF##G###<br>A##B##</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>A<br>CBA<br>BAC<br>DCBFEGA<br>A</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getleft</span><span class="params">(TreeNode * p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		leftnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getright</span><span class="params">(TreeNode *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rightnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode();</span><br><span class="line">	TreeNode(<span class="keyword">char</span> a) &#123; data = a; leftnode = <span class="literal">NULL</span>; rightnode = <span class="literal">NULL</span>; &#125;;</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	TreeNode *leftnode;</span><br><span class="line">	TreeNode *rightnode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(TreeNode* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inoder</span><span class="params">()</span></span>;							<span class="comment">//运用递归进行的中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inoder</span><span class="params">(TreeNode * current)</span></span>;</span><br><span class="line">	TreeNode * root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::inoder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	inoder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::inoder</span><span class="params">(TreeNode* current)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (current)</span><br><span class="line">	&#123;</span><br><span class="line">		inoder(current-&gt;leftnode);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; current-&gt;data;</span><br><span class="line">		inoder(current-&gt;rightnode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span>		<span class="comment">//注意这里的是引用地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> TreeNode(arr[i]);</span><br><span class="line">		i++;</span><br><span class="line">		preinsert(current-&gt;leftnode, arr);</span><br><span class="line">		preinsert(current-&gt;rightnode, arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	binarytree Tree;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	Tree.preinsert(Tree.root, arr);</span><br><span class="line">	Tree.inoder();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#979 输出利用先序遍历创建的二叉树的后序遍历序列</title>
    <url>/swustoj/979/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并输出该二叉树的后序遍历序列。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再输出创建完成的二叉树的后序遍历序列。需要注意输入数据序列中的”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入为接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树）。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>对应的二叉树的后序遍历序列。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>A##<br>ABC####<br>AB##C##<br>ABCD###EF##G###<br>A##B##</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>A<br>CBA<br>BCA<br>DCFGEBA<br>A</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">binarytree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getleft</span><span class="params">(TreeNode * p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		leftnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getright</span><span class="params">(TreeNode *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rightnode = p;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode(<span class="keyword">char</span> a) &#123; data = a; leftnode = <span class="literal">NULL</span>; rightnode = <span class="literal">NULL</span>; &#125;;</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	TreeNode *leftnode;</span><br><span class="line">	TreeNode *rightnode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binarytree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(TreeNode* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pastoder</span><span class="params">()</span></span>;											<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pastoder</span><span class="params">(TreeNode* current)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span></span>;</span><br><span class="line">	TreeNode * root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::pastoder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pastoder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::pastoder</span><span class="params">(TreeNode* current)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (current)</span><br><span class="line">	&#123;</span><br><span class="line">		pastoder(current-&gt;leftnode);</span><br><span class="line">		pastoder(current-&gt;rightnode);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; current-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binarytree::preinsert</span><span class="params">(TreeNode* &amp;current, <span class="keyword">char</span>* arr)</span>		<span class="comment">//注意这里的是引用地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> TreeNode(arr[i]);</span><br><span class="line">		i++;</span><br><span class="line">		preinsert(current-&gt;leftnode, arr);</span><br><span class="line">		preinsert(current-&gt;rightnode, arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	binarytree Tree;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">	Tree.preinsert(Tree.root, arr);</span><br><span class="line">	Tree.pastoder();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#980 输出利用先序遍历创建的二叉树的层次遍历序列</title>
    <url>/swustoj/980/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并输出该二叉树的层次遍历序列。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再输出创建完成的二叉树的层次遍历序列。需要注意输入数据序列中的”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入为接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树）。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>每个用例用一行出该用例对应的二叉树的层次遍历序列。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>A##<br>ABC####<br>AB##C##<br>ABCD###EF##G##H##<br>A##B##</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>A<br>ABC<br>ABC<br>ABHCEDFG<br>A</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	treenode(<span class="keyword">char</span> a):data(a),left(<span class="literal">NULL</span>),right(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	treenode* left;</span><br><span class="line">	treenode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Tree():root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">precreate</span><span class="params">(treenode* &amp;current,<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt;&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levoder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levoder</span><span class="params">(treenode*,<span class="built_in">queue</span>&lt;treenode*&gt;)</span></span>;</span><br><span class="line">treenode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree::precreate</span><span class="params">(treenode* &amp;current,<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt;&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.empty())</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(Q.front()!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		treenode* node=<span class="keyword">new</span> treenode(Q.front());</span><br><span class="line">		Q.pop();</span><br><span class="line">		current=node;</span><br><span class="line">		precreate(current-&gt;left,Q);</span><br><span class="line">		precreate(current-&gt;right,Q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Q.pop();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree::levoder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;treenode*&gt; Q;</span><br><span class="line">	<span class="keyword">if</span>(root)</span><br><span class="line">	Q.push(root);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;空树！&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	levoder(root,Q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree::levoder</span><span class="params">(treenode* current,<span class="built_in">queue</span>&lt;treenode*&gt; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	treenode* temp=Q.front();</span><br><span class="line">	Q.pop();</span><br><span class="line">	<span class="keyword">if</span>(temp-&gt;left) Q.push(temp-&gt;left);</span><br><span class="line">	<span class="keyword">if</span>(temp-&gt;right) Q.push(temp-&gt;right);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;temp-&gt;data;</span><br><span class="line">	<span class="keyword">if</span>(!Q.empty()) levoder(Q.front(),Q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; Q;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.push(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	Tree mytree;</span><br><span class="line">	mytree.precreate(mytree.root,Q);</span><br><span class="line">	mytree.levoder();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#981 统计利用二叉树存储的森林中树的棵数</title>
    <url>/swustoj/981/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>普通树及其构成的森林均可转换成相应的二叉树，反之亦然。故而可以根据相应的转换方法去统计某一二叉树对应的森林中树的棵数。相应的二叉树可利用先序递归遍历算法创建。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再统计该二叉树对应的森林中树的棵数。需要注意输入数据序列中的”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态（序列里面允许无效字符但需要正确处理）。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入为接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树）。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出该用例对应的二叉树表示的森林中树的棵数。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>A#B#CD###<br>ABC####<br>AB##C##<br>ABCD###EF##G##H##<br>A##B##</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>3<br>1<br>2<br>2<br>1</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	treenode(<span class="keyword">char</span> a):data(a),leftnode(<span class="literal">NULL</span>),rightnode(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> data;</span><br><span class="line">treenode* leftnode;</span><br><span class="line">treenode* rightnode;		</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Tree():root(<span class="literal">NULL</span>),count(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">precreate</span><span class="params">(treenode*&amp;,<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;Q)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">treenum</span><span class="params">(treenode* current)</span></span>; </span><br><span class="line"></span><br><span class="line">treenode* root;</span><br><span class="line"><span class="keyword">int</span> count;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree::precreate</span><span class="params">(treenode* &amp; current,<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.empty())</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(Q.front()!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		treenode* temp=<span class="keyword">new</span> treenode(Q.front());</span><br><span class="line">		Q.pop();</span><br><span class="line">		current=temp;</span><br><span class="line">		precreate(current-&gt;leftnode,Q);</span><br><span class="line">		precreate(current-&gt;rightnode,Q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tree::treenum</span><span class="params">(treenode* current)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;rightnode)</span><br><span class="line">	&#123;</span><br><span class="line">		count++;</span><br><span class="line">		treenum(current-&gt;rightnode);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tree mytree;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; Q;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">1000</span>];</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;arr;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;arr[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.push(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	mytree.precreate(mytree.root,Q);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;mytree.treenum(mytree.root);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#982 输出利用二叉树存储的普通树的度</title>
    <url>/swustoj/982/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>普通树可转换成相应的二叉树（该二叉树的根结点一定缺少右儿子），反之亦然。故而可以根据相应的转换方法去统计某一二叉树对应的普通树的度。普通树的度为其结点儿子数的最大值。相应的二叉树可利用二叉树的先序递归遍历算法创建。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后再统计该二叉树对应的森林中树的棵数。需要注意输入数据序列中的”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态（序列里面允许无效字符但需要正确处理）。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入为接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树）。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>若表示的二叉树对应普通树，则该普通树的度；否则输出ERROR。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>AB#CD##E###<br>ABC####<br>AB##C##<br>ABCD###EF##G###<br>A##B##</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>3<br>1<br>ERROR<br>3<br>1</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	treenode(<span class="keyword">char</span> a):data(a),leftnode(<span class="literal">NULL</span>),rightnode(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	treenode* leftnode;</span><br><span class="line">	treenode* rightnode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Tree():root(<span class="literal">NULL</span>),i(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">precreate</span><span class="params">(treenode* &amp;current,<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;Q)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">normal_tree</span><span class="params">(treenode* current,<span class="keyword">int</span> count[<span class="number">100</span>])</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	treenode* root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Tree::check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root-&gt;rightnode!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree::precreate</span><span class="params">(treenode* &amp;current,<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.empty())</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(Q.front()!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		treenode* temp=<span class="keyword">new</span> treenode(Q.front());</span><br><span class="line">		current=temp;</span><br><span class="line">		Q.pop();</span><br><span class="line">		precreate(current-&gt;leftnode,Q);</span><br><span class="line">		precreate(current-&gt;rightnode,Q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree::normal_tree</span><span class="params">(treenode* current,<span class="keyword">int</span> count[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!check())</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(current==<span class="literal">NULL</span>)</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;rightnode)</span><br><span class="line">	&#123;</span><br><span class="line">		count[i]++;</span><br><span class="line">		normal_tree(current-&gt;rightnode,count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(current-&gt;leftnode)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		normal_tree(current-&gt;leftnode,count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; Q;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> count[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;a[k]!=<span class="string">&#x27;\0&#x27;</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.push(a[k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;<span class="number">100</span>;n++)</span><br><span class="line">	&#123;</span><br><span class="line">		count[n]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Tree mytree;</span><br><span class="line">	mytree.precreate(mytree.root,Q);</span><br><span class="line">	mytree.normal_tree(mytree.root,count);</span><br><span class="line">	<span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=mytree.i;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(count[j]&gt;max)</span><br><span class="line">		max=count[j];</span><br><span class="line">		<span class="comment">//cout&lt;&lt;count[j]&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(mytree.check())</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;max;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#984 利用二叉树中序及先序遍历确定该二叉树的后序序列</title>
    <url>/swustoj/984/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>已知二叉树的中序和先序遍历可以唯一确定后序遍历、已知中序和后序遍历可以唯一确定先序遍历，但已知先序和后序，却不一定能唯一确定中序遍历。现要求根据输入的中序遍历结果及先序遍历结果，要求输出其后序遍历结果。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入数据占2行，其中第一行表示中序遍历结果，第二行为先序遍历结果。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>对测试数据，输出后序遍历结果。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>BFDAEGC<br>ABDFCEG</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>FDBGECA</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">tree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	treenode(<span class="keyword">char</span> a) :data(a)&#123;</span><br><span class="line">		left = <span class="literal">NULL</span>;</span><br><span class="line">		right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	treenode* left;</span><br><span class="line">	treenode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tree()&#123;</span><br><span class="line">		root = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(treenode* &amp;T, <span class="keyword">char</span>* pre, <span class="keyword">char</span> *in, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(treenode* T)</span></span>;</span><br><span class="line">	treenode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::create</span><span class="params">(treenode* &amp;T, <span class="keyword">char</span>* pre, <span class="keyword">char</span> *in, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">char</span> * p;</span><br><span class="line">	T = <span class="keyword">new</span> treenode(*pre);</span><br><span class="line">	<span class="keyword">for</span> (p = in; p &lt; in + n; p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*p == *pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;				</span><br><span class="line">	k = p - in;		<span class="comment">//记录根的位置，以便于将其分区</span></span><br><span class="line">	create(T-&gt;left, pre + <span class="number">1</span>, in, k);<span class="comment">//将中序以根为分界 ，左区域</span></span><br><span class="line">	create(T-&gt;right, pre + k + <span class="number">1</span>, p + <span class="number">1</span>, n - k - <span class="number">1</span>);	<span class="comment">//右区域</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::display</span><span class="params">(treenode* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		display(T-&gt;left);</span><br><span class="line">		display(T-&gt;right);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree* T = <span class="keyword">new</span> tree;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> arr_pre[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">char</span> arr_in[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr_in;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; arr_pre;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; arr_in[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	T-&gt;create(T-&gt;root, arr_pre, arr_in, n);</span><br><span class="line">	T-&gt;display(T-&gt;root);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#983 利用二叉树中序及后序遍历确定该二叉树的先序序列</title>
    <url>/swustoj/983/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>已知二叉树的中序和先序遍历可以唯一确定后序遍历、已知中序和后序遍历可以唯一确定先序遍历，但已知先序和后序，却不一定能唯一确定中序遍历。现要求根据输入的中序遍历结果及后序遍历结果，要求输出其先序遍历结果。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>第一行为中序序列<br>第二行为后续序列</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>输出为遍历二叉树得到的先序序列</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>BFDAEGC<br>FDBGECA</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>ABDFCEG</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">tree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	treenode(<span class="keyword">char</span> a) :data(a)</span><br><span class="line">	&#123;</span><br><span class="line">		left = <span class="literal">NULL</span>;</span><br><span class="line">		right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	treenode* left;</span><br><span class="line">	treenode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tree() :root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(treenode* &amp; T, <span class="keyword">char</span> *back, <span class="keyword">char</span> *in, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(treenode* T)</span></span>;</span><br><span class="line">	treenode* root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::create</span><span class="params">(treenode* &amp; T, <span class="keyword">char</span> *back, <span class="keyword">char</span> *in, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">char</span>* p;</span><br><span class="line">	T = <span class="keyword">new</span> treenode(*(back+n<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">for</span> (p = in; p &lt; in + n; p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*p == *(back+n<span class="number">-1</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	k = p - in;</span><br><span class="line">	create(T-&gt;right, (back + n - <span class="number">1</span>)-(n<span class="number">-1</span>-k), in + k +<span class="number">1</span>, n - k - <span class="number">1</span>);</span><br><span class="line">	create(T-&gt;left, back, in, k);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::display</span><span class="params">(treenode* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">		display(T-&gt;left);</span><br><span class="line">		display(T-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> ar_in[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">char</span> ar_back[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; ar_in;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; ar_back;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ar_back[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	tree* T = <span class="keyword">new</span> tree;</span><br><span class="line">	T-&gt;create(T-&gt;root, ar_back, ar_in, n);</span><br><span class="line">	T-&gt;display(T-&gt;root);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>#987 输出用先序遍历创建的二叉树是否为完全二叉树的判定结果</title>
    <url>/swustoj/987/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>利用先序递归遍历算法创建二叉树并判断该二叉树是否为完全二叉树。完全二叉树只能是同深度的满二叉树缺少最后一层倒数连续个叶子结点。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符”#”时表示该结点不需要创建，否则创建该结点。最后判断创建完成的二叉树度是否为完全二叉树。需要注意输入数据序列中的”#”字符和非”#”字符的序列及个数关系，这会最终决定创建的二叉树的形态。</p>
</blockquote>
<a id="more"></a>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote>
<p>输入为接受键盘输入的由大写英文字符和”#”字符构成的一个字符串（用于创建对应的二叉树）。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>对应的二叉树是否为完全二叉树的判断结果。若是输出”Y”，否则输出”N”。</p>
</blockquote>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><blockquote>
<p>A##<br>ABC####<br>AB##C##<br>ABCD###EF##G###<br>A##B##<br>ABC##D##EG###</p>
</blockquote>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><blockquote>
<p>Y<br>N<br>Y<br>N<br>Y<br>Y</p>
</blockquote>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">tree</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	treenode(<span class="keyword">char</span> a) :data(a)</span><br><span class="line">	&#123;</span><br><span class="line">		left = <span class="literal">NULL</span>;</span><br><span class="line">		right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	treenode* left;</span><br><span class="line">	treenode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tree() :root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pre_create</span><span class="params">(treenode* &amp;current, <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt;&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(treenode* root,<span class="built_in">queue</span>&lt;treenode*&gt; &amp;Q)</span></span>;</span><br><span class="line">	treenode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree::pre_create</span><span class="params">(treenode* &amp;current, <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt;&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Q.front() == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.pop();</span><br><span class="line">		current = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		current = <span class="keyword">new</span> treenode(Q.front());</span><br><span class="line">		Q.pop();</span><br><span class="line">		pre_create(current-&gt;left, Q);</span><br><span class="line">		pre_create(current-&gt;right, Q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tree::check</span><span class="params">(treenode* current,<span class="built_in">queue</span>&lt;treenode*&gt;&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			Q.push(current-&gt;left);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Q.push(current-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Q.pop();</span><br><span class="line">	<span class="keyword">if</span> (Q.empty()&amp;&amp;flag==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!check(Q.front(), Q))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; Q1;</span><br><span class="line">	<span class="built_in">queue</span>&lt;treenode*&gt; Q2;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; a[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Q1.push(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	tree T;</span><br><span class="line">	T.pre_create(T.root, Q1);</span><br><span class="line">	Q2.push(T.root);</span><br><span class="line">	<span class="keyword">if</span> (T.check(T.root, Q2))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;N&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SWUSTOJ 题解系列</category>
      </categories>
      <tags>
        <tag>SWUST</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 语言简介【Java 学习笔记 01】</title>
    <url>/20/03/20A/</url>
    <content><![CDATA[<p>Java 之所以可以得到持续的发展力以及良好的生态系统，这完全取决于 Java 自身的技术特征：</p>
<a id="more"></a>

<h1 id="Java-的主要特点"><a href="#Java-的主要特点" class="headerlink" title="Java 的主要特点"></a>Java 的主要特点</h1><ol>
<li>是一个行业内通用的技术实现标准，Java 本身是一个半开源产品，很多厂商能够接触到 Java 的底层，使得 Java 开发更加透明</li>
<li>是一门面向对象编程语言，使得 Java 语言语法结构更加方便开发者接受，且这些面向对象的设计思想还在不断进行着扩充（不同的 JDK 版本）</li>
<li>提供有方便的内存回收处理机制，像一些编程语言里需要明确的手工进行对象的回收与释放，否则程序将不能正常提供支持，但是 Java 提供自动的内存回收操作，这样会更加方便（但是又涉及到优化方面的问题）</li>
<li>避免了复杂的指针问题，而使用更加简单的引用来代替指针，指针虽然是一种高效的内存处理模式，但是需要很强的逻辑分析，而 Java 在设计之初就考虑到了这一点，所以直接利用引用就可以简化指针的处理，而引用也是在初学过程中最为麻烦，最难以理解的部分</li>
<li>Java 是为数不多支持多线程开发的编程语言，这样就可以使得单位时间内处理的性能得到提升（性能的提升并不是绝对的），多线程开发也是 Java 开发之中最难以理解的一部分，而正确的多线程处理才是提升处理性能的核心所在</li>
<li>Java 提供有高效的网络处理能力，可以基于 NIO 实现更加高效的数据传输处理</li>
<li>Java 具有良好的可移植性，这样就可以提升一个程序的适用范围</li>
</ol>
<h1 id="Java-的可移植性"><a href="#Java-的可移植性" class="headerlink" title="Java 的可移植性"></a>Java 的可移植性</h1><p>这是 Java 语言最大的特点，指的是同一个程序可以在不同的操作系统之间进行任意的部署，以此降低了开发的难度</p>
<p>想要实现可移植性的控制，主要是依靠 JVM （Java 虚拟机）</p>
<p>Java 虚拟机是一个由软件和硬件模拟出来的计算机，所有的程序只要有 Java 虚拟机的支持，就可以实现程序的执行，并且不同的操作系统上会有不同的 Java 虚拟机存在，这样就可以实现移植性</p>
<p>所有 Java 程序的解释都要求放在 JVM 里处理</p>
<p>所有 *.java 的源代码程序最终都需要经过编译后才能使用，但是编译完成的程序代码并不是绑定在某个具体操作系统上的程序，而是一种通用性的程序，这种通用性的程序就是 JVM 能够识别的代码</p>
<p>Java 编译器只针对 JVM 产生 *.class 文件，独立于平台之外，所以 *.class 只针对不同的 JVM 生成，由 JVM 去适应平台</p>
<p>所有的 Java 程序并不是直接运行在操作系统上，而是通过 JVM 执行，这样比直接在操作系统上执行程序的处理速度要慢，但是随着硬件技术的提高，这些问题可以忽略，只是依然存在 JVM 的调优问题</p>
]]></content>
      <categories>
        <category>Java 学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 Java 开发环境【Java 学习笔记 02】</title>
    <url>/20/03/20B/</url>
    <content><![CDATA[<p>Java 语言属于编译型和解释型语言的开发语言，如果要进行 Java 开发，一定要进行 JDK （Java 开发工具）的安装配置，JDK 可以实现 Java 语言的编译与解释</p>
<a id="more"></a>

<h1 id="JDK-简介"><a href="#JDK-简介" class="headerlink" title="JDK 简介"></a>JDK 简介</h1><ul>
<li>如果进行实际的项目开发的生产环境部署，现阶段还是应该以使用 JDK 1.8 版本为主</li>
<li>JDK 1.9 和 JDK 1.10 差别不大</li>
<li>JRE 指的是 Java 运行时环境，只提供程序的解释功能，不提供程序的开发功能，当本机上已经配置好了 JDK 之后，将自动进行 JRE 的更新</li>
</ul>
<h1 id="JDK-安装与配置"><a href="#JDK-安装与配置" class="headerlink" title="JDK 安装与配置"></a>JDK 安装与配置</h1><p>安装：不会就自行百度</p>
<p>在 JDK 里所有的可执行程序的路径为：X:\xx\jdk-xx\bin，主要使用 <code>javac.exe</code> 和 <code>java.exe</code>，但是这两个程序并不属于 Windows 本身，如果想要在命令行里面直接使用，就必须在 Windows 的系统环境之中进行可执行程序的路径配置</p>
]]></content>
      <categories>
        <category>Java 学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 Java 开发【Java 学习笔记 03】</title>
    <url>/20/03/20C/</url>
    <content><![CDATA[<p>编写 Java 程序可以不使用特定编辑器，所有 Java 程序的后缀都是 <code>*.java</code>，我们可以建立一个目录保存所有的程序源代码</p>
<a id="more"></a>

<h1 id="Java-编程起步"><a href="#Java-编程起步" class="headerlink" title="Java 编程起步"></a>Java 编程起步</h1><p>定义第一个程序代码：</p>
<p><code>Hello.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 程序需要经过两次处理才可以正常执行：</p>
<ul>
<li>对源代码程序进行编译：<code>javac Hello.java</code>，编译之后会生成一个 <code>Hello.class</code> 的字节码文件，整个过程原理就是利用 JVM 编译出一套与操作平台无关的字节码文件（<code>*.class</code>）</li>
<li>在 JVM 上进行程序的解释：<code>java Hello</code>，<strong>注意：</strong> 这里解释的是字节码文件，字节码文件的后缀（<code>*.class</code>）是不需要编写的</li>
</ul>
<p>解释一下第一个程序：</p>
<ol>
<li>在 Java 程序开发中最基础的单元是类，所有的程序都必须封装在类当中执行，而类的基本定义语法如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="class"><span class="keyword">class</span> 类名称 </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在程序中定义的类名称是：<code>Hello</code>，类的定义有两种形式：</p>
<ul>
<li><code>public class 类名称 &#123;&#125;</code>：类名称必须与文件名称保持一致，在一个 <code>*.java</code> 文件里只能有一个 <code>public class</code> 定义</li>
<li><code>class 类名称 &#123;&#125;</code>：类名称可以与文件名称不一致，但是编译后的 <code>*.class</code> 的名称是 <code>calss</code> 定义的类，解释的时候要求解释生成的 <code>*.class</code> 字节码文件，在一个 <code>*.java</code> 文件里面可以有多个 <code>class</code> 定义，并且编译之后会生成不同的 <code>*.class</code> 文件</li>
</ul>
<p><strong>注意：</strong> 关于源代码类定义的问题：</p>
<ul>
<li>在项目开发中，很少会出现在一个 <code>*.java</code> 源代码里面定义多个 <code>class</code> 类的情况，所以一般在一个 <code>*.java</code> 源代码里就定义一个 <code>public class</code> 类就够了</li>
<li>Java 语言有着明确的要求，定义类名称的时候要求每一个单词的首字母必须大写，eg. HelloWorld、TestDemo 这样才符合标准</li>
</ul>
<ol start="2">
<li>主方法：是所有程序执行的起点，并且一定要定义在类中，Java 的主方法定义：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 程序的代码由此开始执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <code>String args[]</code> &lt;=&gt; <code>String [] args</code></p>
<p>必须记住主方法怎么写，即使没有代码补全也能写出来，主方法所在的类统一称为 “主类”，所有的 “主类” 都使用 <code>public class 类名称 &#123;&#125;</code> 来定义</p>
<ol start="3">
<li>屏幕打印（系统输出）：可以直接在命令行方式下进行内容的显示，有如下两种语法：</li>
</ol>
<ul>
<li>输出之后追加换行：<code>System.out.println(输出内容);</code></li>
<li>输出之后不追加换行：<code>System.out.print(输出内容);</code></li>
</ul>
<h1 id="JShell-工具"><a href="#JShell-工具" class="headerlink" title="JShell 工具"></a>JShell 工具</h1><p>Shell 是脚本程序的含义，在很多编程语言里面为了方便使用者进行代码开发，都会有 Shell 交互式编程环境，可能只是为了一些简短的程序验证，但是在 Java 里面需要编写很多的结构代码才能实现，所以为了解决这样的麻烦，提供了 JShell 指令，直接 cmd 执行指令 <code>jshell</code> 即可</p>
<p>除了可以直接在 JShell 命令之中进行程序的编写之外，也可以将一些内容交给一些文件来进行保存</p>
<p>eg. 在 <code>D:/hello.txt </code> 写入如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">system.out.println(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>

<p>在 JShell 执行指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;open d:&#x2F;hello.txt</span><br></pre></td></tr></table></figure>

<p>屏幕能够成功输出 <code>hello</code></p>
<p>所以使用 JShell 只需要编写核心结构的代码即可，减少了对于结构化的需求，执行指令 <code>/exit</code> 即可退出 JShell 交互式界面</p>
<h1 id="CLASSPATH-环境属性"><a href="#CLASSPATH-环境属性" class="headerlink" title="CLASSPATH 环境属性"></a>CLASSPATH 环境属性</h1><p>CLASSPATH 完整理解非常复杂，这里暂时了解其概念</p>
<p>eg. 在 <code>D:/JavaCode</code> 下有一个叫 <code>Hello.class</code> 的字节码文件，当前用户所在的目录为 <code>D:/JavaCode</code>，那么在这种情况之下可以直接使用 <code>java</code> 命令进行 <code>Hello.class</code> 字节码文件的解释，但是如果现在用户脱离了这个目录，去到了 <code>C:/</code> （C 盘目录下并没有 <code>Hello.class</code> 字节码文件），如果再次执行程序解释，会出现错误提示：<code>找不到或无法加载主类 Hello</code></p>
<p>如果我们要执行不同目录下的程序，就需要依靠 CLASSPATH 环境属性</p>
<p>定义 CLASSPATH 环境属性：<code>SET CLASSPATH = D:/JavaCode</code></p>
<p>设置了 CLASSPATH 之后，这个时候在 Java 程序解释的时候会自动通过 CLASSPATH 所设置的路径进行类的加载，所以可知：JVM 解释程序的时候需要得到 CLASSPATH 的支持</p>
<p>但是在默认情况下，所有解释的类都是从当前所在的目录中加载的，所以可知：CLASSPATH 的默认设置为当前所在目录加载类文件，很明显如果在非当前目录设置 CLASSPATH 就会使整个系统操作混乱，所以最好采用默认的设置，如果这时候想只通过当前目录加载，则可以将 CLASSPATH 设置为 <code>.</code></p>
<p>eg. 设置从当前所在路径加载类 <code>SET CLASSPATH = .</code></p>
<p>有些时候如果安装了一些与 Java 开发相关的程序，它可能会自动修改默认的 CLASSPATH，所以就需要自己设置回来</p>
<p><strong>注意：</strong> 现在 CLASSPATH 是在一个命令行下的配置，如果该命令行关闭了，那么相关的属性配置也将消失，所以应该将其定义为全局属性，则可以直接在系统中追加一个属性信息</p>
<p>配置方法：新建用户变量 <code>CLASSPATH = .</code></p>
<p>PATH 和 CLASSPATH 的区别？</p>
<ul>
<li>PATH：是操作系统提供的路径配置，定义所有可执行程序的路径</li>
<li>CLASSPATH：是 JRE 提供的，用于定义 Java 程序解释时的类加载路径，默认设置为当前目录加载，可以通过 <code>SETCLASSPATH = 路径</code> 的命令形式来进行定义</li>
</ul>
<p>JVM 解释字节码文件的寻访过程：JVM ➡ CLASSPATH 定义的路径 ➡ 加载字节码文件，所以 CLASSPATH 是 Java 定义的环境属性，是在 Java 程序解释的时候使用的</p>
]]></content>
      <categories>
        <category>Java 学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基本概念【Java 学习笔记 04】</title>
    <url>/20/03/20D/</url>
    <content><![CDATA[<p>注释是程序开发之中的一项重要组成技术，合理的注释能使项目维护更加方便</p>
<a id="more"></a>

<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>在 Java 语言里面注释一共有三类：</p>
<ul>
<li>单行注释：// xxxxxx</li>
<li>多行注释：/* xxxxx */</li>
<li>文档注释：/** xxxxx */，文档注释里面还需要很多的选项，一般建议共同开发工具控制</li>
</ul>
<p>eg. 定义单行注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单行注释：下面的语句是进行一行提示信息的输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg. 定义多行注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        单行注释：</span></span><br><span class="line"><span class="comment">        下面的语句是进行一行提示信息的输出</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用开发工具开发时，还是单行注释会比较方便，而对于一些重要的类和方法都建议使用文档注释</p>
<h1 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h1><p>在任何程序之中，都是一个结构的整合体，在 Java 语言里面有不同的结构，eg. 类、方法、变量结构等，对于不同的结构一定要有不同的说明，对于结构的说明实际上就是标识符，是有命名要求的，但是一般都是要求有意义的单词所组成，同时对于标识符的组成在 Java 之中定义如下：</p>
<ul>
<li>由字母、数字、_、$ 所组成</li>
<li>不能使用数字开头</li>
<li>不能使用 Java 中的保留字（关键字）</li>
</ul>
<p>最简单的定义标识符的形式：使用英文开头，对于 $ 一般都有特殊的含义，不建议出现在自己所编写的代码之中</p>
<p>关键字：系统对于一些结构的描述处理，有特殊的含义，eg. public、class 等，Java 中的关键字一共有如下内容：</p>
<ul>
<li>不需要背，必要时可上网查</li>
</ul>
<p>对于关键字的定义不需要背，对于部分关键字有一些简短说明</p>
<ul>
<li>JDK 1.4 =》assert 关键字，用于异常处理</li>
<li>JDK 1.5 =》enum 关键字，用于枚举定义</li>
<li>未使用到的关键字：goto、const</li>
<li>还有一些属于特殊含义的单词，严格来讲不算关键字：true、false、null</li>
</ul>
]]></content>
      <categories>
        <category>Java 学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据类型划分【Java 学习笔记 05】</title>
    <url>/20/03/20E/</url>
    <content><![CDATA[<p>程序是一套数字处理的游戏框架，在程序开发的过程之中，最终目的就是对一些数据进行处理，就必须提供各种类型的数据定义</p>
<a id="more"></a>

<h1 id="Java-数据类型简介"><a href="#Java-数据类型简介" class="headerlink" title="Java 数据类型简介"></a>Java 数据类型简介</h1><p>Java 中数据类型一共分为两类：</p>
<ul>
<li>基本数据类型：描述的是一些具体的数字单元<ul>
<li>数值型<ul>
<li>整型：byte、short、int、long ➡ 默认值：0</li>
<li>浮点型：float、double ➡ 默认值：0.0</li>
</ul>
</li>
<li>布尔型：boolean ➡ 默认值：false</li>
<li>字符型：char ➡ 默认值：’\u0000’</li>
</ul>
</li>
<li>引用数据类型：牵扯到内存关系的使用<ul>
<li>数组、类、接口 ➡ 默认值：null</li>
</ul>
</li>
</ul>
<p>每一种基本的数据类型都有每一种类型保存的数据范围，这将影响数据类型的选择，数据类型使用参考原则：</p>
<ul>
<li>如果描述数字，首选：int（整数）、double（小数）</li>
<li>如果要进行数据传输或者进行文字编码转换，使用：byte（二进制处理操作）</li>
<li>处理中文，最方便使用：char</li>
<li>描述内存或者文件大小或者表的主键列可以使用：long</li>
</ul>
<h1 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h1><p>整型数据一共有 4 种，按照保存范围由小到大：byte、short、int、long，在 Java 里面任何的一个整型常量其默认数据类型都是 int 型（只要是整数就是 int 型）</p>
<p>eg. 定义 int 型变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int 变量名 = 常量</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">// 定义了一个整型变量的 a</span></span><br><span class="line">        a = <span class="number">20</span>; <span class="comment">// 改变已有变量的值</span></span><br><span class="line">        <span class="comment">// int 型变量 * int 型变量 = int 型数据</span></span><br><span class="line">        System.out.println(a * a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量是可以改变的，常量是不会变化的</p>
<p>任何数据类型都有其可以保存的范围，正常使用下很少会出现超出范围的数据，如果超出最大的保存范围，将会出现循环的问题，在 Java 种这种现象叫数据溢出，解决数据溢出的办法：</p>
<ul>
<li>在操作的时候预估数据范围，如果发现范围不够，就是用更大数据范围的数据类型</li>
<li>直接从常量上进行处理，默认的整数常量是 int 型，可以为它追加字母 <code>L</code> 或直接使用 <code>(long)</code> 转换</li>
</ul>
<p>eg. 数据类型转换：int ➡ long</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2L</span> <span class="comment">// 追加字母 L</span></span><br><span class="line"><span class="number">2l</span> <span class="comment">// 同样的追加字母 l，但是一定避免使用小写字母 l</span></span><br><span class="line">(<span class="keyword">long</span>)<span class="number">2</span> <span class="comment">// 强制转换</span></span><br></pre></td></tr></table></figure>

<p>数据类型之间是可以相互转换的，范围小的数据类型可以自动转为范围大的数据类型，但是范围大的数据类型转换成范围小的数据类型必须使用强制性的处理模式，并且同时还有可能发生数据溢出，所以不建议使用强制转换</p>
<p>在进行整型处理的时候，byte 类型的范围是 -128 ~ 127 之间，它保存的数据量很小</p>
<p>eg. 定义 byte 变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> num = <span class="number">10</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 程序里面 20 应该是 int 型的数据，但是在为 byte 赋值的时候并没有因是 int 型就发生强制转换，这是因为 Java 对 byte 做了特殊处理，即：如果没超过 byte 范围的常量可以自动由 int 变为 byte，如果超过就必须强制转换</p>
<p>对于常量，可以自动适配转换，对于变量则还是必须使用强制转换</p>
<h1 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h1><p>浮点型数据描述的是小数，在 Java 里任意一个小数常量对应的类型为 double，建议以后描述小数都是用 double</p>
<p>所有数据类型进行自动转型的时候都是由小类型向大类型转换，默认的小数类型为 double，但是也可以定义位数相对较少的 float 变量，这时 eg. <code>float = 11.1</code> 会报错，因为小数默认为 double，必须使用强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11.1F</span></span><br><span class="line"><span class="number">11.1f</span></span><br><span class="line">(<span class="keyword">float</span>)<span class="number">11.1</span></span><br></pre></td></tr></table></figure>

<p>整型是不包含小数点的，如果整型的计算结果有小数会自动省去</p>
<h1 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h1><p>字符型使用 char 定义，使用 <code>&#39;&#39;</code> 括起来，在任何编程语言中，字符都可以与 int 相互转换，即字符所描述的内容可以通过 int 获取其内容对应的系统编码</p>
<ul>
<li>大写字母编码范围：A（65）~ Z（90）</li>
<li>小写字母编码范围：a（97）~ z（122）</li>
<li>数字编码范围：’0’（48）~ ‘9’（57）</li>
</ul>
<p>Java 中允许 char 定义中文字符，因为 Java 使用的是 unicode 十六进制编码，该编码特点是可以包含任意文字内容</p>
<h1 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h1><p>布尔主要描述的是一种逻辑的处理结果，在 Java 中使用 boolean 来进行布尔类型的变量定义，布尔类型的取值范围只有两个数据：true、false</p>
<p>有一些编程语言，由于并没有提供布尔类型，所以会使用 0 标识 false，使用非 0 标识 true，但是这样的逻辑在 Java 中不存在</p>
<h1 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h1><p>在任何编程语言里面都没有提供字符串这种基本数据，但是从实际使用上来讲，各个编程语言为了方便程序开发，也会提供字符串的相应描述，在 Java 里面使用 String 作为字符串的定义，由于 String 类存在比较特殊，所以其可以像普通变量那样采用直接赋值的方式进行字符串的定义，并使用 <code>&quot;&quot;</code> 将字符串括起来</p>
<p>在使用字符串变量的时候，可以使用 <code>+</code> 来连接不同的字符串</p>
<p>在 Java 语言里面，数据范围大的数据与数据范围小的数据进行计算的时候，数据范围小的数据会自动转为数据范围大的数据，而当存在 String 时，所有类型无条件变为 String</p>
<p>在描述字符串的时候可以使用转义字符进行一些处理：</p>
<ul>
<li>TAB《=》<code>\t</code></li>
<li>“《=》<code>\&quot;</code></li>
<li>‘《=》<code>\&#39;</code></li>
<li>换行《=》<code>\n</code></li>
<li>\《=》<code>\\</code></li>
</ul>
]]></content>
      <categories>
        <category>Java 学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 运算符【Java 学习笔记 06】</title>
    <url>/20/03/20F/</url>
    <content><![CDATA[<p>所有的程序开发就是一种数字处理游戏，对于数字的处理一定会有所谓的操作模式，而这些操作模式就称为运算符，在程序开发中，会提供大量的基础运算符，这些运算符都有自己各自的优先顺序，不用记住，<code>()</code> 优先级最高，合理使用 <code>()</code> 就可以了</p>
<a id="more"></a>

<h1 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h1><p> 在 Java 中数学运算都提供了标准的支持，包括四则运算等等，在进行变量计算的时候，编程语言一般都会提供简化的运算符支持</p>
<p>eg. num = num + 1《=》num += 1</p>
<p><code>++</code> 、<code>--</code> 的两类运算方法：</p>
<ul>
<li>++num、–num：先进行 num 的自增或者自减，在进行数字计算</li>
<li>num++、num–：先进行 num 的数字计算，再进行自增或者自减</li>
</ul>
<p>最好不使用以上操作，怎么简单怎么写</p>
<h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><p> 关系运算的主要特征就是进行大小的比较处理，包括：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">// 大于</span></span><br><span class="line">&lt; <span class="comment">// 小于</span></span><br><span class="line">&gt;= <span class="comment">// 大于等于</span></span><br><span class="line">&lt;= <span class="comment">// 小于等于</span></span><br><span class="line">!= <span class="comment">// 不等于</span></span><br><span class="line">== <span class="comment">// 等于</span></span><br></pre></td></tr></table></figure>

<p>所有的关系运算返回的判断结果都是布尔类型数据，进行关系判断的时候特别注意等于的判断，使用 <code>==</code>，进行关系运算的时候可以针对所有的基本数据类型，也可以使用字符来进行关系运算，因为数据类型之间提供转型支持，所以再进行字符的判断的时候，字符会自动转为 int 而后进行数字的比较</p>
<h1 id="三目赋值运算符"><a href="#三目赋值运算符" class="headerlink" title="三目赋值运算符"></a>三目赋值运算符</h1><p>在进行程序开发的时候三目运算符使用得很多，而且合理使用三目运算可以避免大范围程序编写，三目是一种所谓的赋值运算的处理，它是需要设置一个逻辑关系的判断之后才可以进行的赋值操作，基本语法：</p>
<p><code>关系运算 ? 关系满足时的内容 : 关系不满足时的内容</code></p>
<p>eg. 判断两个数字的大小，输出最大数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> max = a &gt; b ? a : b;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序开发的核心要点：尽可能精简代码</p>
<p>三目运算本身也可以进行嵌套处理，也就是说在赋值语句的位置上可以进一步编写三目运算，但是程序可读性会降低，根据实际情况决定是否嵌套</p>
<p>eg. 三目运算的嵌套</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">int</span> max = a &gt; b ? (a &gt; c ? a : c) : (b &gt; c) ? b : c;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算是指可以直接进行二进制数据的计算处理，主要有：&amp;（与）、|（或）、^（异或）、~（反码）、移位运算</p>
<p>想理解位操作，一定要清楚十进制与二进制之间转换的逻辑：数字除以 2 取余数，eg. 13 ➡ 1101，注意：Java 中的整型是 32 位，所以：13 ➡ 00000000 00000000 00000000 00001101</p>
<p>eg. 与操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">13</span>, b = <span class="number">7</span>;</span><br><span class="line">        System.out.println(a &amp; b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运算过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span> 的二进制 ➡ <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001101</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span> 的二进制  ➡  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000111</span></span><br><span class="line"></span><br><span class="line">&amp; 的结果    ➡  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span> ➡ <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>在进行位运算的时候还可以进行移位运算，eg. 求 2 的 3 次方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        System.out.println(a &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运算过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> 的二进制： ➡ <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000010</span></span><br><span class="line">向左移 <span class="number">2</span> 位：➡ <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001000</span> ➡ <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>&amp; 和 &amp;&amp;、| 和 || 的区别：</p>
<ul>
<li>&amp; 和 | 是两个可以进行位运算与逻辑运算的运算符<ul>
<li>在进行逻辑运算的时候所有的判断条件都要执行 </li>
<li>在进行位运算的时候只是对当前数据进行与、或处理</li>
</ul>
</li>
<li>在逻辑运算上还可以使用 &amp;&amp;、||<ul>
<li>&amp;&amp;：在进行若干个条件判断的时候，如果前面的条件返回了 false，后续所有的条件都不再判断，最终的结果就是 false</li>
<li>||：在进行若干个条件判断的时候，如果前面的条件返回了 true，后续所有的条件都不再判断，最终的结果就是 true</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java 学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 程序逻辑控制【Java 学习笔记 07】</title>
    <url>/20/03/21A/</url>
    <content><![CDATA[<h1 id="if-分支结构"><a href="#if-分支结构" class="headerlink" title="if 分支结构"></a>if 分支结构</h1><p>程序开发的过程中会存在三种程序逻辑：顺序结构、分支结构、循环结构，if 分支结构主要是针对关系表达式进行判断处理的分支操作，分支语句主要有三种使用形式，使用的关键字：if、else</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式) &#123;</span><br><span class="line">    条件满足时执行;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式) &#123;</span><br><span class="line">    条件满足时执行;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式) &#123;</span><br><span class="line">    条件满足时执行;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    条件不满足时执行;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 if 最主要的特点就是它可以进行若干个条件判断，进行多条件判断时可以不写 else 语句，但是最好总是写上 else 语句</p>
<h1 id="switch-开关语句"><a href="#switch-开关语句" class="headerlink" title="switch 开关语句"></a>switch 开关语句</h1><p>switch 是一个开关语句，它主要是根据内容来进行判断，需要注意的是 switch 中可以判断的只能是数据（int、char、枚举、String），switch 不能使用逻辑判断，注意：JDK 1.7 之后才支持 String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (数据) &#123;</span><br><span class="line">    <span class="keyword">case</span> 数值:</span><br><span class="line">        数值满足时执行;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 数值:</span><br><span class="line">        数值满足时执行;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        所有数值均不满足时执行;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 语句在进行设计的时候，如果没有在每一个 case 后面追加 break 语句，那么会在第一个匹配的 case 之后继续执行，知道全部 switch 中的后续代码执行完毕或者遇见 break</p>
<h1 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h1><p>在程序之中提供有 while 语句来实现循环，该语句有两种定义形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">while</span> (布尔表达式) &#123;</span><br><span class="line">    条件满足时执行;</span><br><span class="line">    修改循环条件;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do...while</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    条件满足时执行;</span><br><span class="line">    修改循环条件;</span><br><span class="line">&#125; <span class="keyword">while</span> (布尔表达式);</span><br></pre></td></tr></table></figure>

<p>while 循环与 do…while 循环的区别：</p>
<ul>
<li>while 是先判断再执行</li>
<li>do…while 是先执行一次再判断</li>
</ul>
<p>实际开发中一般很少用到 do…while</p>
<h1 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h1><p>for 循环定义的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (定义循环的初始化数值; 循环判断; 修改循环数据) &#123;</span><br><span class="line">    循环语句的执行;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 while 和 for 循环的选择只有一个参考标准：</p>
<ul>
<li>在明确确定循环次数的情况下，优先使用 for 循环</li>
<li>在不知道循环次数，但是知道循环结束条件的情况下，优先使用 while 循环</li>
</ul>
<h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><p>在循环语句定义的时候通常会使用到的两个循环控制语句：break，continue</p>
<ul>
<li>break 的主要功能是退出整个循环结构</li>
<li>continue 只是结束当前一次循环的执行，跳过当前一次循环</li>
</ul>
<p>利用 continue 实现 goto 的功能（不建议开发时使用如上代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        point: <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">10</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;<span class="number">3</span>; y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">                    <span class="keyword">continue</span> point;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h1><p>在一个循环语句之中嵌套其他循环语句，循环嵌套的层次越多，时间复杂度越高</p>
<p>eg. 打印乘法口诀表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a=<span class="number">1</span>; a&lt;<span class="number">10</span>; a++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b=<span class="number">1</span>; b&lt;=a; b++) &#123;</span><br><span class="line">                System.out.print(a + <span class="string">&quot; x &quot;</span> + b + <span class="string">&quot;= &quot;</span> + (a*b) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg. 打印三角形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> line = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;line; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;line-x; y++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;=x; y++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java 学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 方法的定义及使用【Java 学习笔记 08】</title>
    <url>/20/03/23A/</url>
    <content><![CDATA[<p>在程序之中，很多情况下需要重复执行一些代码，方法（method）也称之为函数，需要注意的是，进行方法定义有一个前提：方法在主类中定义并且由主方法直接调用</p>
<a id="more"></a>

<h1 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h1><p>方法的返回值可以使用 Java 中定义的数据类型（基本数据类型、引用数据类型），在方法之中可以进行返回数据的处理，如果要返回数据就是用 return 来描述，return 返回的数据类型与方法返回值的数据类型相同，如果不返回数据则该方法可以使用 void 进行声明</p>
<p>关于方法名称与变量的定义命名要求：</p>
<ul>
<li>方法名称：第一个单词字母小写，而后每个单词的首字母大写</li>
<li>变量名称：第一个单词字母小写，而后每个单词的首字母大写</li>
</ul>
<p>方法的定义可以方便使用者重复调用，所有的程序都是从主方法开始的，方法定义不要太长，应使单个方法容易理解</p>
<p>在进行方法定义的时候，如果方法的返回值类型为 void，那么可以利用 return 来结束调用</p>
<h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>当方法名称相同，参数的类型或者个数不同的时候就叫方法重载</p>
<p>eg. 不同类型的数据进行加法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(sum(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">20.0</span>, <span class="number">10.1</span>));</span><br><span class="line">        System.out.println(sum(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y + z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一个方法名称可以根据调用时传递的不同参数的类型或个数实现不同方法体的调用，这就实现了方法重载的定义，方法的重载与方法的返回值类型没有任何关系，只与参数有关，但是实际开发中：只要是方法重载，建议保持其方法的返回值类型相同</p>
<p>eg. <code>System.out.println();</code> 就是一个系统自带的方法重载，它可以接收不同数据类型的参数</p>
<h1 id="方法递归调用"><a href="#方法递归调用" class="headerlink" title="方法递归调用"></a>方法递归调用</h1><p>方法的递归调用指的是一个方法自己调用自己，利用递归调用可以解决一些重复且麻烦的问题，在进行方法递归调用时，需要考虑如下问题：</p>
<ul>
<li>一定要设置方法递归调用的结束条件</li>
<li>每一次调用的过程之中一定要修改传递的参数条件</li>
</ul>
<p>eg. 利用递归求 1 + 2 + 3 + … … + 1000</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num + sum(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归可以简化代码调用，但是实际开发很少会出现递归，大部分情况下都只是考虑一些简单的处理逻辑，递归如果使用不当，则会造成内存溢出</p>
<p>eg. 计算 1! + 2! + 3! + … … + 90!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(sum(<span class="number">90</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fan(num) + sum(num -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">fan</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num * fan(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上有一部分递归是可以通过循环来完成的，但是使用递归要比使用循环结构更清晰简洁</p>
]]></content>
      <categories>
        <category>Java 学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类与对象【Java 学习笔记 09】</title>
    <url>/20/03/24A/</url>
    <content><![CDATA[<p>Java 语言最大的特点在于面向对象的编程设计，并且面向对象的编程设计也在由于 Java 自身的发展而不断发展，同时很多最初不支持面向对象的编程语言都开始转向了面向对象编程，但也有人认为面向过程编程会更好，或者是使用函数式编程会更好</p>
<a id="more"></a>

<h1 id="面向对象简介"><a href="#面向对象简介" class="headerlink" title="面向对象简介"></a>面向对象简介</h1><p>最早出现并且流行至今的编程语言主要有 C、C++、Java，其中 C 语言已经成为了面向过程开发的代表，C++ 和 Java 都是面向对象的编程语言</p>
<p>所谓的面向过程指的是面对一个问题的解决方案，更多情况下是不会做出重用的设计思考，而面向对象的主要设计思想就是模块化设计，并且可以重用配置，在整个面向对象的设计里面，更多的情况下考虑的是标准，在使用的时候根据标准进行拼装</p>
<p>面向对象还有三个主要特征：</p>
<ul>
<li>封装性：内部的操作对外部不可见，当内部的操作都不可直接使用的时候才是最安全的</li>
<li>继承性：在已有结构的基础上继续进行功能的扩充</li>
<li>多态性：是在继承性的基础上扩充的概念，指的是类型的转换处理</li>
</ul>
<p>在进行面向对象开发时还有三个步骤：</p>
<ul>
<li>OOA：面向对象分析</li>
<li>OOD：面向对象设计</li>
<li>OOP：面向对象编程</li>
</ul>
<h1 id="类与对象简介"><a href="#类与对象简介" class="headerlink" title="类与对象简介"></a>类与对象简介</h1><p>面向对象的核心就是类与对象，类是对某一类事物的共性的抽象概念，而对象描述的是一个具体的产物，对象与对象之间不同的是对象各自的属性，每一个属性的集合就构成了对象，但是所有的属性都是群体的定义，而群体的定义就形成了一个类</p>
<p>类是一个模板，而对象就是类可以使用的实例，先定义类才可以定义对象，但是类不能直接使用，对象可以直接使用，在类之中一般都会有两个组成：</p>
<ul>
<li>成员属性（Field）：也可以称为属性</li>
<li>成员行为（Method）：定义对象具有的处理行为</li>
</ul>
<h1 id="类与对象的定义和使用"><a href="#类与对象的定义和使用" class="headerlink" title="类与对象的定义和使用"></a>类与对象的定义和使用</h1><p>在 Java 中类是一个独立的结构体，所以需要使用 class 来进行定义，而在类之中主要由属性和方法组成，属性就是一个个具体的变量，而方法就是可以重复执行的代码</p>
<p>eg. 定义一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是&quot;</span> + name + <span class="string">&quot;，我今年&quot;</span> + age + <span class="string">&quot;岁了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在已经定义了一个类了，其中包含两个属性和一个方法，如果要使用这个类，必须通过对象来完成，而如果要产生对象，就必须使用如下代码格式：（对象必须经过实例化之后才能使用）</p>
<ul>
<li>声明并实例化对象：类名称 对象名称 = new 类名称();</li>
<li>分步完成：<ul>
<li>声明对象：类名称 对象名称 = null;</li>
<li>实例化对象：对象名称 = new 类名称();</li>
</ul>
</li>
</ul>
<p>当获取了实例化对象之后，那么就需要通过对象进行类中的操作调用，有两种调用方式：</p>
<ul>
<li>调用类中的属性：实例化对象.成员属性;</li>
<li>调用类中的方法：实例化对象.方法名称();</li>
</ul>
<p>eg. 使用对象操作类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am &quot;</span> + name + <span class="string">&quot;, I&#x27;m &quot;</span> + age + <span class="string">&quot; years old&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person(); <span class="comment">// 声明并实例化对象</span></span><br><span class="line">        per.name = <span class="string">&quot;Kiring&quot;</span>;</span><br><span class="line">        per.age = <span class="number">20</span>;</span><br><span class="line">        per.talk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果此时的程序没有进行对象属性内容的设置，则该数据内容为其数据类型对应的默认值</p>
<h1 id="对象内存分析"><a href="#对象内存分析" class="headerlink" title="对象内存分析"></a>对象内存分析</h1><p>Java 之中类属于引用数据类型，引用数据类型最大的困难在于要进行内存的管理，同时进行操作的时候也会发生内存关系的变化，所以要掌握程序内存关系的简单分析</p>
<p>如果要进行内存分析，首先先给出两块最为常用的内存空间：</p>
<ul>
<li>堆内存：保存的是对象的具体信息，在程序之中，堆内存空间的开辟是通过 new 完成的</li>
<li>栈内存：保存的是一块堆内存的地址，即：通过地址找到堆内存，进而找到对象内容，但是有时候为了简化分析，可以简单的理解为：对象名称保存在栈内存之中</li>
</ul>
<h1 id="对象引用分析"><a href="#对象引用分析" class="headerlink" title="对象引用分析"></a>对象引用分析</h1><p>类本身属于引用数据类型，会涉及到内存的引用传递，引用传递的本质就是：同一块堆内存空间可以被不同的栈内存所指向，也可以更换指向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per1 = <span class="keyword">new</span> Person(); <span class="comment">// 声明并实例化对象</span></span><br><span class="line">        per1.name = <span class="string">&quot;Kiring&quot;</span>;</span><br><span class="line">        per1.age = <span class="number">20</span>;</span><br><span class="line">        Person per2 = per1; <span class="comment">// 引用传递</span></span><br><span class="line">        per2.age = <span class="number">30</span>;</span><br><span class="line">        per1.talk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候的引用传递是直接在主方法之中定义的，也可以通过方法实现引用传递，这个时候一定要观察方法的参数类型，同时也要观察方法的执行过程，如下：程序是将 Person 类的实例化对象（内存地址-数值）传递到了 change() 方法之中，由于传递的是一个 Person 类型，那么 change() 方法接收的也是 Person 类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person(); <span class="comment">// 声明并实例化对象</span></span><br><span class="line">        per.name = <span class="string">&quot;Kiring&quot;</span>;</span><br><span class="line">        per.age = <span class="number">20</span>;</span><br><span class="line">        change(per); <span class="comment">// Person temp per</span></span><br><span class="line">        per.talk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Person temp)</span> </span>&#123;</span><br><span class="line">        temp.age = <span class="number">80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="引用与垃圾产生分析"><a href="#引用与垃圾产生分析" class="headerlink" title="引用与垃圾产生分析"></a>引用与垃圾产生分析</h1><p>引用传递如果处理不当，会造成垃圾的产生，所谓的垃圾空间就是没有任何栈内存所指向的堆内存空间，所有的垃圾将被 GC（Garbage Collector）不定期进行回收并且释放无用内存空间，但是如果垃圾过多，一定会影响 GC 的处理性能，从而降低整体的程序性能，所以在实际的开发之中，对于垃圾的产生应该越少越好</p>
<p>一个栈内存只能保存一个堆内存的地址数据，如果发生更改，则之前的地址数据将从此栈内存中彻底消失</p>
]]></content>
      <categories>
        <category>Java 学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>记·博客搭建</title>
    <url>/20/03/24B/</url>
    <content><![CDATA[<p>这是我第二次使用 <code>GitHub + Hexo</code> 搭建个人博客，所以成功的搭建起来并没有花太多时间，但还是遇到了一些问题，所以在此记录一下这些“🕳”，以及记录我自己添加到博客的内容。</p>
<a id="more"></a>

<p>最近有一些小伙伴留言说希望了解我站点的部分配置，有这一需求的可以查看我在 GitHub 上的站点备份👉<a href="https://github.com/TUFZ/TUFZ.github.io/tree/backup">传送门</a></p>
<h1 id="必知概念"><a href="#必知概念" class="headerlink" title="必知概念"></a>必知概念</h1><ul>
<li>站点根目录</li>
</ul>
<p>安装 Hexo 的文件夹就是站点根目录，例如我的：<code>F:\Blog\TUFZ\Hexo</code></p>
<ul>
<li>站点配置文件</li>
</ul>
<p>配置站点的文件 <code>_config.yml</code>，注意与主题配置文件区分，例如我的站点配置文件：<code>F:\Blog\TUFZ\Hexo\_config.yml</code></p>
<ul>
<li>主题配置文件</li>
</ul>
<p>配置主题的文件，在主题文件夹里，例如我的主题配置文件：<code>F:\Blog\TUFZ\Hexo\themes\ayer\_config.yml</code></p>
<h1 id="一些-“🕳”"><a href="#一些-“🕳”" class="headerlink" title="一些 “🕳”"></a>一些 “🕳”</h1><h2 id="bash-hexo-command-not-found"><a href="#bash-hexo-command-not-found" class="headerlink" title="bash: hexo: command not found"></a>bash: hexo: command not found</h2><p>首先检查一下 node.js 和 npm 是否正常，使用命令 <code>node -v</code> 和 <code>npm -v</code> 查看版本，如果有版本信息即一切正常，那么应该就是 Hexo 的环境变量没有添加，进入 Hexo –&gt; node_modules –&gt; .bin，复制 .bin 的文件路径，例如：<code>F:\Blog\TUFZ\Hexo\node_modules\.bin</code></p>
<p>将该路径添加到系统变量的 Path 变量里，重新使用 hexo 命令即可成功执行，如还不能成功执行，重新执行 Hexo 安装语句：<code>npm install hexo-cli -g</code></p>
<h1 id="添加音乐"><a href="#添加音乐" class="headerlink" title="添加音乐"></a>添加音乐</h1><p>使用👉<a href="https://github.com/MoePlayer/hexo-tag-aplayer">hexo-tag-aplayer</a>👈插件，最新版的 aplayer 支持 MetingJS，意味着它可以解析几乎所有网络平台的音乐资源，</p>
<p><strong>安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure>

<p>安装好之后按理说就可以直接使用了，但是最好先配置一下 MetingJS，以免某些平台的音乐资源无法被解析，打开站点的配置文件，写入如下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">    <span class="attr">meting:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="创建歌单页面"><a href="#创建歌单页面" class="headerlink" title="创建歌单页面"></a>创建歌单页面</h2><p>👉<a href="https://www.itufz.com/playlist/">这里</a>👈是我的歌单页面</p>
<p><strong>1、首先我们新建一个 playlist</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page playlist</span><br></pre></td></tr></table></figure>

<p><strong>2、配置 playlist</strong></p>
<p>执行完新建页面命令之后，在 <code>Hexo\source</code> 文件夹下面会生成一个 playlist 文件夹，该文件夹里面有一个 index.md文件，这个 <code>.md</code> 文件会经过渲染解析生成 playlist 页面，所以我们所有关于页面的代码都在这里编写</p>
<p><strong>注意：</strong>Markdown 真的很强大，可以在里面直接写前端代码</p>
<p>以下是我的 index.md</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 音乐</span><br><span class="line">type: &quot;playlist&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">音乐的力量💪</span><br><span class="line"></span><br><span class="line">&#123;% meting &quot;4924170567&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#FF4081&quot; &quot;mode:circulation&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125;</span><br></pre></td></tr></table></figure>

<p>以上 <code>4924170567</code> 是歌单的 id，随后 “netease” 表示音乐平台是网易云音乐，后面的可以默认或者查看官方说明进行修改</p>
<p><strong>3、配置访问路径</strong></p>
<p>至此我们的 playlist 页面已经准备好了，但是还没有访问入口，所以我们应该在主题配置文件里配置访问路径</p>
<p>打开 <code>F:\Blog\TUFZ\Hexo\themes\ayer\_config.yml</code>，一般第一条配置就是 menu，先看一下我的配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 侧边栏菜单</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags</span></span><br><span class="line">  <span class="string">相册:</span> <span class="string">/photos</span></span><br><span class="line">  <span class="string">音乐:</span> <span class="string">/playlist</span></span><br><span class="line">  <span class="string">关于我:</span> <span class="string">/about</span></span><br></pre></td></tr></table></figure>

<p>可以理解为 <code>/</code> 表示 <code>F:\Blog\TUFZ\Hexo\source</code> 文件夹，所以音乐的路径就是 <code>/playlist</code>，至此该页面已经完全配置完成</p>
<h2 id="给文章添加音乐"><a href="#给文章添加音乐" class="headerlink" title="给文章添加音乐"></a>给文章添加音乐</h2><p>在文章中添加音乐只需要在文章中加入一段代码，示例：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 示例文章</span><br><span class="line">date: 2020-03-25 09:34:11</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">    -</span> Blog</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&#123;% meting &quot;3986040&quot; &quot;netease&quot; &quot;song&quot; &quot;theme:#555&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125;</span><br><span class="line"></span><br><span class="line">这是我的演示文章，将上面的代码添加在哪个位置音乐就会出现在文章的哪个位置，上面的 <span class="code">`3986040`</span> 是歌曲的 id，&quot;netease&quot; 表示音乐资源来自于网易云音乐，后面的可以默认</span><br></pre></td></tr></table></figure>

<p>aplayer 是支持给单篇文章添加音乐的，但是我在使用中却发现：当我给文章添加了音乐之后，文章的 TOC 就不能使用了</p>
<p>该问题暂时未解决，该问题可能只在主题 ayer 上出现，其他主题未测试</p>
<h2 id="音乐更新时间"><a href="#音乐更新时间" class="headerlink" title="音乐更新时间"></a>音乐更新时间</h2><p>我是使用网易云音乐歌单来实现音乐页面的歌曲更新的，每当网易云音乐歌单收藏里更新了音乐之后，一般 12 个小时之后博客才会更新</p>
<h1 id="配置相册"><a href="#配置相册" class="headerlink" title="配置相册"></a>配置相册</h1><p>👉<a href="https://www.itufz.com/photos/">这里</a>👈是我的相册页面</p>
<p>配置相册跟配置音乐页面的原理一样的，先新建一个相册页面，在根目录执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page photos</span><br></pre></td></tr></table></figure>

<p>然后在 <code>Hexo\source</code> 下会生成一个 photos 文件夹，里面有一个 index.md 文件，文件配置如下：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 相册</span><br><span class="line">type: &quot;photos&quot;</span><br><span class="line"></span><br><span class="line">albums: [</span><br><span class="line"><span class="code">		[&quot;https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/cover/cover1.jpg&quot;, &quot;Cover1&quot;],</span></span><br><span class="line"><span class="code">		[&quot;https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/cover/cover2.jpg&quot;, &quot;Cover2&quot;],</span></span><br><span class="line"><span class="code">		[&quot;https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/cover/cover8.png&quot;, &quot;Cover8&quot;]</span></span><br><span class="line"><span class="code">]</span></span><br><span class="line"><span class="code">---</span></span><br></pre></td></tr></table></figure>

<p>albums 里存放的就是图片了，每一个 [] 前面的部分是图片的 URL，后面的部分是图片名称，当然你还可以编写一些代码来美化你的相册</p>
<p>最后一步，给你的相册配置一个入口路径，我是配置在侧边栏的，所以打开主题配置文件，在 menu 中添加一条配置：<code>相册: /photos</code></p>
<h1 id="设置文章置顶"><a href="#设置文章置顶" class="headerlink" title="设置文章置顶"></a>设置文章置顶</h1><p>使用👉<a href="https://github.com/netcan/hexo-generator-index-pin-top">hexo-generator-index-pin-top</a>👈插件</p>
<p><strong>1、删除 hexo-generator-index 插件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br></pre></td></tr></table></figure>

<p><strong>2、安装 hexo-generator-index-pin-top 插件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>

<p><strong>3、文章配置</strong></p>
<p>在文章的 <code>Front-matter</code> 中添加 <code>top: true</code>，比如我的这篇文章：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 记·博客搭建纪要</span><br><span class="line">date: 2020-03-24 18:05:51</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet"> -</span> Blog</span><br><span class="line">categories: 记录</span><br><span class="line">photos: https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/assets/20-03-24-1.jpeg</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p><strong>4、修改置顶图标样式</strong></p>
<p>打开：<code>/Hexo/themes/next/layout/_macro</code> 目录下的 <code>post.swig</code> 文件，定位到 <code>&lt;div class=&quot;post-meta&quot;&gt;</code> 标签下，插入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">   &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>但是由于我的博客主题自带文章置顶功能，所以我完成前 3 步后我的文章就已经置顶且有一个挺不错的置顶标识了</p>
<h1 id="配置后台管理（不推荐，已弃用）"><a href="#配置后台管理（不推荐，已弃用）" class="headerlink" title="配置后台管理（不推荐，已弃用）"></a>配置后台管理（不推荐，已弃用）</h1><blockquote>
<p>使用了一段时间还是弃用了，hexo-admin 只能本地后台管理，并不实用，唯一让我眼前一亮的就是后台写文章有 Markdown 实时渲染，但是左右页面内容并不一致，会错位，体验就很差了，对了，还有一个点，在后台写文章可以直接添加图片，hexo-admin 会自动在 <code>Hexo/source</code> 下创建一个 <code>images</code> 文件夹存放添加的图片，然后使用相对路劲引用图片到文章，并不是利用图床，这样是方便了，但是也会导致网页打开需要加载的数据变得很大，拖慢页面加载速度</p>
</blockquote>
<p>这里使用👉<a href="https://github.com/jaredly/hexo-admin">hexo-admin</a>👈插件</p>
<p><strong>注意：hexo-admin 只能在本地进行后台管理</strong></p>
<p><strong>1、安装插件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-admin --save</span><br></pre></td></tr></table></figure>

<p>然后我们本地部署看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server -d</span><br></pre></td></tr></table></figure>

<p>进入 <code>http://127.0.0.1:4000/admin/</code> 即可查看后台</p>
<p><strong>2、设置账号密码</strong></p>
<p>点击 <strong>Setting</strong></p>
<p>可以选择开启行数统计和拼写检查</p>
<ul>
<li>Enable line numbering.</li>
<li>Enable spellchecking.(buggy on older browsers)</li>
</ul>
<p>然后点击 <strong>Setup authentification here</strong></p>
<p>填写以下信息：</p>
<ul>
<li>Username</li>
<li>Password</li>
<li>Secret（这个我也不清楚是什么，随意填吧）</li>
</ul>
<p>然后下拉就可以看见自动生成了 <strong>Admin Config Section</strong></p>
<p>复制里面的信息，打开站点配置文件 <code>_config.yml</code> 粘贴进去，至此配置已经完成</p>
<p>然后重新部署以下博客</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server -d</span><br></pre></td></tr></table></figure>

<p>进入 <code>http://127.0.0.1:4000/admin/</code>，此时就需要我们输入之前设置的账号密码登陆</p>
<blockquote>
<p>害，当时就该遇到问题记录一下， 现在都不知道我遇到了什么问题，尴尬😅，未完… … 这个坑一定要填</p>
</blockquote>
]]></content>
      <categories>
        <category>博客纪要</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建我的多端云同步生态</title>
    <url>/20/03/27A/</url>
    <content><![CDATA[<p>写篇文章用来简单记录一下我的多端云同步生态的搭建思路以及过程</p>
<p>现在真的是云上时代啊，所有东西都放在云端的感觉很奇妙，一伸手就能拿到，用完了它自己就能同步修改</p>
<a id="more"></a>

<h1 id="一朵☁"><a href="#一朵☁" class="headerlink" title="一朵☁"></a>一朵☁</h1><p>不管你使用📱还是电脑，或者是平板，只需要一朵☁，当然不能是百度云，我使用的坚果云，那个曾经一直被我误以为是🔨的坚果的坚果云，真的是好用，免费版每个月的传输流量于我已经足够，再加上它桀骜不驯从不打折，会员可能是用不上了</p>
<p>所以我的多端云同步的核心就是坚果云，这朵☁足够快速，空间也足够我使用，其实到目前为止我只利用坚果云搭建了一个同步系统，它只有一个功能，就是同步管理我的账号密码</p>
<p>然后我还将纯纯写作和记时光备份在坚果云，纯纯写作的备份机制真的很强大，一旦配置可以完全不用再管它，而记时光到目前为止我的使用体验感受一般（可能是因为我对它的需求不高，所以使用频率也很低），备份坚果云似乎需要手动备份（每次进入 App 也会启动备份），而且一次备份就是上传所有备份文件压缩包</p>
<h1 id="我的生态圈："><a href="#我的生态圈：" class="headerlink" title="我的生态圈："></a>我的生态圈：</h1><h2 id="1-账号密码同步管理系统"><a href="#1-账号密码同步管理系统" class="headerlink" title="1. 账号密码同步管理系统"></a>1. 账号密码同步管理系统</h2><ul>
<li>电脑端：KeePass</li>
<li>Android：KeePass2Android</li>
</ul>
<p>电脑端使用 KeePass 将密码数据库创建在坚果云同步文件夹内，将 KeePass2Android 与坚果云上的密码数据库文件通过 Webdav 链接，使用密码数据库的管理密码 + 密钥文件打开数据库，进而查看、管理账号密码</p>
<p>Android 一旦发生改动，坚果云会自动同步密码数据库文件，在电脑端打开密码数据库密码已然更新，即完成数据同步，同理在电脑端发生改动，经坚果云同步后，Android 端访问密码数据库看到的已经是最新的数据了</p>
<h2 id="2-纯纯写作同步管理系统"><a href="#2-纯纯写作同步管理系统" class="headerlink" title="2. 纯纯写作同步管理系统"></a>2. 纯纯写作同步管理系统</h2><ul>
<li>Android：纯纯写作</li>
<li>电脑端：Pure Wirter Alpha</li>
</ul>
<p>这个系统其实并不依靠坚果云实现同步，甚至他们之间根本不能同步，我只是使用坚果云通过 Webdav 实时备份我在纯纯写作创作的内容，依然可以看作是使用坚果云管理我的写作内容</p>
<p>然而纯纯写作电脑端与 Android 的同步则是能是写作时的文字输入瞬间同步，依靠局域网连接实现，但是效果真的很棒，虽然现在电脑端处于 Alpha 阶段会经常断连，可是依然不影响我喜欢用它</p>
<h2 id="3-Evernote-附件寄存系统"><a href="#3-Evernote-附件寄存系统" class="headerlink" title="3. Evernote 附件寄存系统"></a>3. Evernote 附件寄存系统</h2><p>同样的在这个系统里依然不存在多端同步的内容，但是它却是依托坚果云解决了我的大麻烦</p>
<p>Evernote 每个月保存的笔记是有流量限制的，所以一旦我的笔记里需要插入什么文件那我这个月的给定流量可能不能撑到月底，我是不会开会员的（国内的印象笔记真的越来越臃肿，最近准备迁移至 WizNote），而现在，当我需要在笔记里添加文件时，我会将文件上传到坚果云，然后通过连接分享写入 Evernote 笔记里，很大程度的节省了我的 Evernote 每月流量</p>
<h2 id="4-私人云盘系统"><a href="#4-私人云盘系统" class="headerlink" title="4. 私人云盘系统"></a>4. 私人云盘系统</h2><p>我将坚果云作为自己的私人云盘，仅仅用于保存小体积、使用频率高的文件，因为它空间小又因为它速度快，即可以代替我的 OneDrive，更能代替我的百度云，当然百度云还是要用的，只是仅仅用来存放体积庞大、不经常使用的文件</p>
<h2 id="5-易码笔记同步管理系统"><a href="#5-易码笔记同步管理系统" class="headerlink" title="5. 易码笔记同步管理系统"></a>5. 易码笔记同步管理系统</h2><ul>
<li>Android：易码</li>
<li>电脑端：支持 MarkDown 的文本编辑器，我使用 Typora</li>
</ul>
<p>易码的 MarkDown 文件是以“库”的形式保存，“库”可以是本地文件夹，也可以是云盘里的文件夹，同时易码支持 Webdav，所以我在坚果云里创建同步文件夹，在易码中将其设置为“库”</p>
<p>这样当我在易码里编辑 MarkDown 文档，就会通过 Webdav 保存至坚果云，同时电脑端可以同步更新，使用编辑器在电脑端修改文件之后经过坚果云同步，易码上刷新就会同步最新的“库”</p>
<p>但是易码的开发者已经停止了对于易码的维护，所以我现在也一直在寻找新的替代品，前段时间纯纯写作的作者 Darkeet 说纯纯后续会支持完全云同步，替代易码指日可待✌</p>
<h2 id="6-未完待续…"><a href="#6-未完待续…" class="headerlink" title="6. 未完待续…"></a>6. 未完待续…</h2><p>更多坚果云的使用配方我一直还在研究中…</p>
]]></content>
      <categories>
        <category>互联网生活优化指南</category>
      </categories>
      <tags>
        <tag>坚果云</tag>
        <tag>WebDAV</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学概论</title>
    <url>/20/04/07A/</url>
    <content><![CDATA[<blockquote>
<p>定义：计算机图形学就是研究如何在计算机中表示图形，以及利用计算机进行图形的计算、处理和显示的相关原理与算法</p>
</blockquote>
<p>生成图形的三个步骤：</p>
<ol>
<li>造型技术</li>
<li>光照模型</li>
<li>绘制（渲染）技术</li>
</ol>
<a id="more"></a>

<h1 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h1><p>渲染一幅三维图像所涉及的知识，实际上就是计算机图形中每个像素看上去应该是什么颜色的问题，这很大程度上取决于不同的光照模型</p>
<p>计算机屏幕是由很多像素构成的，像素作为构成图形的基本单位，为了在屏幕上显示一幅图形，就必须研究在哪些像素上生成图形，就必须有一套针对光栅显示器生成图形的算法</p>
<p>光栅显示器：</p>
<p>七十年代诞生，现在使用的显示器都是光栅显示器，光栅显示器的屏幕是由像素组成</p>
<h1 id="图形软件："><a href="#图形软件：" class="headerlink" title="图形软件："></a>图形软件：</h1><ol>
<li>图形应用数据结构</li>
</ol>
<p>实际上是对应一组图形数据文件，其中存放着欲生成的图形对象的全部描述信息</p>
<ol start="2">
<li>图形应用软件</li>
</ol>
<p>是解决某种应用问题的图形软件，是图形系统中的核心部分，包括了各种图形生成和处理技术，是图形技术在各种不同应用中的抽象</p>
<p>eg. PhotoShop、3Dmax etc.</p>
<ol start="3">
<li>图形支撑软件</li>
</ol>
<p>大多数图形应用程序是建立在一定的图形支撑软件上的，图形支撑软件需要具有规范接口</p>
<p>OpenGL（Open Graphics Library）：一个功能强大，调用方便的底层图形库</p>
<h1 id="图形显示设备："><a href="#图形显示设备：" class="headerlink" title="图形显示设备："></a>图形显示设备：</h1><ol>
<li>CRT 显示器</li>
</ol>
<p>一种使用阴极射线管的显示器，阴极射线管主要由五部分组成，分别是：电子枪、偏转线圈、荫罩、荧光粉层和玻璃外壳，<strong>是曾经应用最广泛的显示器之一</strong></p>
<p>CRT 显示器可以显示不同颜色的图形，彩色 CRT 显示器的荧光屏涂有三种荧光物质，分别能发出 红、绿、蓝 三种颜色的光，从而混合出不同颜色</p>
<ol start="2">
<li>LCD 显示器</li>
</ol>
<p>液晶显示器，工作原理是在显示器内部有很多液晶粒子，它们有规律的排列成一定的形状，并且它们每一面的颜色分别为：红、绿、蓝，当显示器接收到电脑的显示数据时，会控制每个液晶粒子转动到不同颜色的面，从而组合成不同的颜色和图像</p>
<ol start="3">
<li>LED 显示器</li>
</ol>
<p>发光二极管。是一种能将电能转化为光能的半导体电子元件，早期只能发出低光度的红光，现在能发出的光已经遍及可见光、红外线和紫外线</p>
<ol start="4">
<li>等离子显示器</li>
</ol>
<p>继 CRT 显示器、LCD 显示器之后的新一代显示器，厚度极薄、分辨率高，其成像原理是在显示屏上排列上千个密封的小低气压气体室，通过电流激发使其发出肉眼不可见的紫外线，然后紫外线碰击后面玻璃上的红、绿、蓝三种颜色的荧光体发出肉眼可见的光，以此成像</p>
<ol start="5">
<li>3D 显示器</li>
</ol>
<p>传统的 3D 电影在屏幕上有两组图像，观众需要戴上偏光镜以消除重影，形成视差，产生立体感</p>
<p>利用立体显示技术的“真 3D”，实际上是利用“视差栅栏”，是两只眼睛分别接收不同的图像，来形成立体效果</p>
<h1 id="帧缓冲器与屏幕像素"><a href="#帧缓冲器与屏幕像素" class="headerlink" title="帧缓冲器与屏幕像素"></a>帧缓冲器与屏幕像素</h1><p>光栅扫描的帧缓冲器对屏幕每一点都有存储 强度/颜色 信息的能力，在计算机屏幕上画一幅图像，需要计算每一个像素的 RGB 值，在帧缓存里写 RGB 相当于在屏幕上画颜色</p>
<p>帧缓冲器单元个数至少与显示器能显示的像素总数相同，且存储单元一一对应于可寻址的屏幕像素位置</p>
<p>显示器的分辨率表示的是在屏幕上扫描一行一共有多少个点，一共有多少行扫描线</p>
<p>帧缓冲器的每一个存储单元的位长决定了一幅画面上能同时显示的不同灰度的数目或颜色的种类</p>
<p>eg.</p>
<ul>
<li>如果是单色，则每个像素只需要 1Bit</li>
<li>如果是 16 色，则每个像素需要 4Bit（2⁴ = 16）</li>
<li>如果是 256 色，则每个像素需要 1 字节（8 位，2⁸ = 256）</li>
<li>如果是 65536（64K）色，则每个像素需要 2 字节（16 位，2¹⁶ = 64K）</li>
<li>如果是 16777216（16.7M）色，则每个像素需要 3 字节（24 位，2²⁴ = 16.7M，24 位真彩色）</li>
</ul>
<p>计算显存的大小与其所支持的最大分辨率和色彩数的对应关系：</p>
<p>eg. 显卡有 2MB 显存，当分辨率为 1024x768 时，可支持的色彩数？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2MB &#x3D; 2*1024*1024 &#x3D; 2097152 #字节</span><br><span class="line">1024x768 &#x3D; 786432 #像素</span><br></pre></td></tr></table></figure>

<h1 id="分辨率的基础知识"><a href="#分辨率的基础知识" class="headerlink" title="分辨率的基础知识"></a>分辨率的基础知识</h1><p>屏幕分辨率：屏幕上显示的像素个数</p>
<p>显示分辨率：计算机控制器所能提供的显示模式的分辨率</p>
<ul>
<li>对于文本显示方式：显示分辨率用水平和垂直方向上所能显示的字符总数的乘积表示</li>
<li>对于图形显示方式：显示分辨率用水平和垂直方向上所能显示的像素点总数的乘积表示</li>
</ul>
<p>显卡分辨率：表示显卡输出给显示器，并且能在显示器上描绘像素点的数量</p>
<p>Tips：</p>
<ul>
<li>显卡能输出的最大分辨率并不代表自己的电脑就能达到这样高的分辨率，还必须有足够强大的显示器</li>
<li>一台电脑的最高分辨率由显卡和显示器共同决定，取决于最低的一方</li>
<li>显示器最高分辨率是可以显示出来的最大分辨率</li>
<li>显卡最高分辨率是能支持的最大分辨率</li>
</ul>
<p>显示器的点距：指相邻像素点之间的距离，两点之间的距离越小越好</p>
<p>对于 14、15 英寸显示器，0.28mm 的点距已经足够，而对于更大屏幕的显示器则需要更小的点距指标</p>
<p><strong>显卡的作用与性能：</strong></p>
<p>基本作用就是显示图文，显卡 + 显示器构成了计算机的显示系统，显卡对于计算机的显示性能起着很重要的作用，现在的显卡还可以替代一部分 CPU 的功能，帮助处理数据</p>
<h1 id="图形与图像"><a href="#图形与图像" class="headerlink" title="图形与图像"></a>图形与图像</h1><p>区别：</p>
<ul>
<li><p>说法一：图形是由计算机绘制的，图像是认为利用外部设备捕捉到的外部的景象</p>
</li>
<li><p>说法二：图形是矢量图，图像式位图（点阵图）</p>
</li>
</ul>
<p>位图：又称点阵图或像素图，计算机屏幕上的图由屏幕上像素构成，每个点用二进制数据来描述其颜色与亮度等信息</p>
<p>矢量图：又称面向对象的图形或绘图图形，是用数学方式描述的曲线及曲线围成的色块制作的图形</p>
<p>矢量文件中的图形元素称为对象，每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性</p>
<p><strong>矢量图与位图的区别：</strong></p>
<ol>
<li>存储方式</li>
</ol>
<ul>
<li>点阵文件是存储图的各个像素点的位置信息、颜色信息以及灰度信息</li>
<li>矢量文件是用数学方程、数学形式对图像进行描述，通常是用图形的形状参数和属性等参数来表示图形</li>
</ul>
<p>点阵文件存储空间比矢量文件大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#相互转换</span><br><span class="line"></span><br><span class="line">矢量文件 ---扫描转换---&gt;&gt;&gt; 点阵文件</span><br><span class="line">矢量文件 &lt;&lt;&lt;---图像处理--- 点阵文件</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>缩放度</li>
</ol>
<p>位图与分辨率有关，即在一定面积的图像上包含固定数量的像素</p>
<p>矢量图与分辨率无关，可以将其缩放到任意大小和以任意分辨率在输出设备上打印出来，都不会影响清晰度</p>
<ol start="3">
<li>存储格式</li>
</ol>
<p>位图：BMP、TIFF、GIF、JPEG、PNG</p>
<p>矢量图：DXF、SVG、EPS、WMF、EMF</p>
<p>位图比矢量图更容易模仿真实感图形效果，但存储空间更大</p>
<p>在图形缩放时，矢量图不会失真，适用于文字设计、图案设计、版式设计、计算机辅助设计、工艺美术设计、插画 etc.</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>我是如何提升我的网站访问速度的？</title>
    <url>/20/04/07B/</url>
    <content><![CDATA[<p>这是提升前后的网站响应速度对比：</p>
<ul>
<li>提升之前👇</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr07B/00.png" alt="00.png"></p>
<ul>
<li>提升之后👇</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr07B/01.png" alt="01.png"></p>
<p>绿油油的真不错！✔</p>
<a id="more"></a>

<h1 id="GitHub-Coding"><a href="#GitHub-Coding" class="headerlink" title="GitHub + Coding"></a>GitHub + Coding</h1><p>最开始我的网站只在 GitHub 托管，由于 GitHub 服务器在海外，从大天朝访问总是时断时续的，然后我看到了 <a href="https://www.itrhx.com/">TRHX</a> 的 Hexo 系列中讲如何实现 GitHub + Coding 双线部署的文章</p>
<blockquote>
<p>建议小白们熟读并背诵 TRHX 的 Hexo 系列[滑稽]</p>
</blockquote>
<p>然后我就在 Coding 上也部署了我的博客，具体操作👉<a href="https://blog.csdn.net/qq_36759224/article/details/100879609">传送门</a></p>
<p>这里我只补充一点点，由于 Coding 被腾讯收购，后来的 Coding 就和腾讯云开发者平台合并了，所以不管你是从 <code>https://coding.net/</code> 还是 <code>https://dev.tencent.com/</code> 登陆注册都是一样的会进入 Coding</p>
<p>还有就是关于仓库开启 Pages 服务，很多人找不到在哪部署静态网站，因为 Coding 新建仓库只默认开启如图的功能，其他功能开关需要自己打开</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting/TUFZ-Img/article/2020/04/20Apr07B/02.png" alt="02.png"></p>
<ul>
<li>点击左下角<strong>项目设置</strong></li>
<li>点击右侧<strong>功能开关</strong></li>
<li>开启<strong>构建与部署</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting/TUFZ-Img/article/2020/04/20Apr07B/03.png" alt="03.png"></p>
<p>然后回到你的仓库，在左侧构建与部署里点击静态网站，就可以开始部署 Pages 服务了</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting/TUFZ-Img/article/2020/04/20Apr07B/04.png" alt="04.png"></p>
<p>当我完成一顿操作之后，部署成功了，但是我的站点访问更慢了！！！🤢</p>
<blockquote>
<p>Tips：Coding 的服务器在新加坡</p>
</blockquote>
<h1 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h1><p>中文版 GitHub，服务器在国内，之前也在上面托管过代码，但是一直没想到它也有 Pages 服务</p>
<p>以下是我在码云上部署站点的过程</p>
<p>码云上即使你的仓库与用户名不同也可以开启 Pages 服务，但是如果不使用与用户名相同的仓库，部署 Pages 服务之后你的首页访问地址将带有二级目录，这会影响之后的域名解析</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr07B/05.png" alt="05.png"></p>
<p>步骤：</p>
<h2 id="1-创建一个与用户名同名的仓库"><a href="#1-创建一个与用户名同名的仓库" class="headerlink" title="1. 创建一个与用户名同名的仓库"></a>1. 创建一个与用户名同名的仓库</h2><p>略</p>
<h2 id="2-复制仓库的-HTTPS-地址"><a href="#2-复制仓库的-HTTPS-地址" class="headerlink" title="2. 复制仓库的 HTTPS 地址"></a>2. 复制仓库的 HTTPS 地址</h2><p>当然使用 SSH 也是可以的，个人推荐码云可以使用 HTTPS，因为速度够快，使用也更方便</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr07B/06.png" alt="06.png"></p>
<h2 id="3-在站点目录里配置仓库地址"><a href="#3-在站点目录里配置仓库地址" class="headerlink" title="3. 在站点目录里配置仓库地址"></a>3. 在站点目录里配置仓库地址</h2><p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr07B/07.png" alt="07.png"></p>
<h2 id="4-推送站点代码"><a href="#4-推送站点代码" class="headerlink" title="4. 推送站点代码"></a>4. 推送站点代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>当 Git 开始向码云推送代码时，系统会弹出窗口需要你输入你的码云用户名 + 密码，这就完成了本地与码云的连接</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr07B/11.png" alt="11.png"></p>
<h2 id="5-开启-Pages-服务"><a href="#5-开启-Pages-服务" class="headerlink" title="5. 开启 Pages 服务"></a>5. 开启 Pages 服务</h2><p>点击仓库右上角<strong>服务</strong><br>点击<strong>Gitee Pages</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr07B/08.png" alt="08.png"></p>
<p>这里一切默认即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr07B/09.png" alt="09.png"></p>
<h2 id="6-域名解析"><a href="#6-域名解析" class="headerlink" title="6. 域名解析"></a>6. 域名解析</h2><p>略</p>
<h1 id="最后优化"><a href="#最后优化" class="headerlink" title="最后优化"></a>最后优化</h1><p>又是一顿操作下来，我已经将我的站点同时部署在 GitHub + Coding + Gitee 上了，然后测试发现国内绝大部分地区访问我的站点时解析的都是码云的 IP 地址，所以码云的访问速度完胜</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr07B/10.PNG" alt="10.png"></p>
<p>最后我放弃了继续使用 Coding，而 GitHub 也只作为站点备份，所以我在控制台中停掉了 GitHub + Coding 的解析</p>
]]></content>
      <categories>
        <category>博客纪要</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>【分享】阿里巴巴 Java 开发手册</title>
    <url>/20/04/09A/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">版本号</th>
<th align="center">制定团队</th>
<th align="center">更新日期</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.5.0</td>
<td align="center">阿里巴巴与 Java 社区开发者</td>
<td align="center">2019.06.19</td>
<td align="center">华山版，新增 21 条，修改描述 112 处</td>
</tr>
</tbody></table>
<p>分享连接👉<a href="https://www.jianguoyun.com/p/DaJUaZwQxamWCBiV_YsD">传送门</a></p>
<p><a href="https://edu.aliyun.com/certification/cldt02?spm=5176.8764728.aliyun-edu-course-header.11.5fc352bbywdkFm">阿里巴巴 Java 编码规范认证</a></p>
<p>阅读前请先了解部分专有名词解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr09A/00.png" alt="00.png"></p>
]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>多边形扫描转换算法</title>
    <url>/20/04/13A/</url>
    <content><![CDATA[<p>没有简介就是最好的简介🙃</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>多边形有两种重要的表示方法：</p>
<ul>
<li><strong>顶点</strong>表示</li>
</ul>
<p>用多边形的顶点序列来表示多边形，这种表示直观、几何意义强、占内存少，易于进行几何变换</p>
<p>但是因为它没有明确指出哪些像素在多边形内，所以不能直接用于面着色</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting/TUFZ-Img/article/2020/04/20Apr13A/00.png" alt="00.png"></p>
<ul>
<li><strong>点阵</strong>表示</li>
</ul>
<p>用位于多边形内部的像素集合来刻画多边形，这种表示丢失了许多几何信息（eg. 边界、顶点 etc.），但它却是光栅显示系统显示时所需的表示形式</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting/TUFZ-Img/article/2020/04/20Apr13A/01.png" alt="01.png"></p>
<p>把多边形的顶点表示转换为点阵表示，这种转换就称之为<strong>多边形的扫描转换</strong></p>
<p>多边形分为：凸多边形、凹多边形、含内环的多边形 etc.</p>
<ol>
<li>凸多边形：多边形内任意两点间的连线均在多边形内部</li>
<li>凹多边形：多边形内任意两点间的连线存在不在多边形内部的</li>
<li>含内环的多边形：多边形内包含多边形</li>
</ol>
<p>多边形扫描转换要解决的问题是：在知道多边形的边界时，找到多边形内部的点，即把多边形内部填上颜色</p>
<h1 id="X-扫描线算法"><a href="#X-扫描线算法" class="headerlink" title="X-扫描线算法"></a>X-扫描线算法</h1><p>基本思想：按照扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间里的像素</p>
<p>算法的核心：按照 x 递增顺序排列交点的 x 坐标序列</p>
<p><strong>步骤：</strong></p>
<ol>
<li>确定多边形所占有的最大扫描线数量，得到多边形顶点的最大值和最小值（$y_{max}$ 和 $y_{min}$）</li>
<li>从 $y = y_{min}$ 到 $y = y_{max}$，每次用一条扫描线进行填充，又分为如下四个步骤：<ol>
<li>求交：计算扫描线与多边形各边的交点</li>
<li>排序：把所有交点按递增顺序进行排序</li>
<li>配对：把交点根据区间进行配对（交点必须是偶数个，第1、2个交点一对，第3、4个交点一对）</li>
<li>区间填色：把这些相交区间内的像素置成不同于背景色的填充色</li>
</ol>
</li>
</ol>
<p>当扫描线与多边形顶点相交时，交点的取舍问题：</p>
<ol>
<li>若共享顶点的两条边分别在扫描线的两边，交点只算<strong>一个</strong></li>
<li>若共享顶点的两条边在扫描线的同一边，交点算<strong>零个</strong>或者<strong>两个</strong></li>
</ol>
<p>如何判断共享顶点的两条边的位置：检查共享顶点的两条边的另外两个端点的 y 值，按这两个 y 值中大于交点 y 值的个数来决定交点数（个数为几交点就为几）</p>
<p>为了计算每条扫描线与多边形各边的交点，最简单的方法是把多边形的所有边放在一个表中，在处理每条扫描线的时候，按顺序从表中间取出所有的边，分别与扫描线求交</p>
<p><strong>但是！！！</strong>这个算法的效率非常低，因为求交运算的计算量十分大</p>
<h1 id="改进-X-扫描线算法"><a href="#改进-X-扫描线算法" class="headerlink" title="改进 X-扫描线算法"></a>改进 X-扫描线算法</h1><p>最理想的算法是<strong>不求交</strong></p>
<p>扫描转换算法提出的重要思想：</p>
<ol>
<li>扫描线：当处理图形图像时按一条条扫描线处理</li>
<li>增量的思想</li>
</ol>
<p>在求交点时使用增量，因为每条扫描线的 y 值都是知道的，所以关键的是求 x 的值</p>
<p><strong>改进方案：</strong></p>
<p>1. 在处理一条扫描线时，仅对与它相交的多边形的边（有效边）进行求交运算</p>
<p>eg. 如图，只计算扫描线与 $P_{1}P_{4}$ 和 $P_{2}P_{3}$ 的交点</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13A/02.png" alt="02.png"></p>
<p>2. 考虑扫描线的连贯性</p>
<p>即当前扫描线与各边的交点顺序与下一条扫描线与各边的交点顺序很可能相同或非常相似</p>
<p>3. 多边形的连贯性</p>
<p>即当某条边与当前扫描线相交的时候，它很可能也与下一条扫描线相交</p>
<p>为了避免求交运算，需要引进一套特殊的数据结构：</p>
<p>1. 活性边表（AET）：把与当前扫描线相交的边称为活性边，并把它们按与扫描线交点 x 坐标递增的顺序存放在一个链表里</p>
<p>2. 节点内容（一个节点在数据结构中可以用结构来表示）：</p>
<p>$x$：当前扫描线与边的交点坐标</p>
<p>$\Delta x$：从当前扫描线到下一条扫描线之间 x 的增量</p>
<p>$y_{max}$：该边所交的最高扫描线的 y 坐标值 $y_{max}$</p>
<p>next：指向下一条边的指针</p>
<table>
<thead>
<tr>
<th align="center">$x$</th>
<th align="center">$\Delta x$</th>
<th align="center">$y_{max}$</th>
<th align="center">next</th>
</tr>
</thead>
</table>
<p>随着扫描线的移动，扫描线与多边形的交点与上一次交点相关：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13A/03.png" alt="03.png"></p>
<p>设边的直线斜率为 $k$：</p>
<p>$$k = \frac{\Delta y}{\Delta x} = \frac{y_{i+1} - y_{i}}{x_{i+1} - x_{i}}$$</p>
<p>$$\because y_{i+1} - y_{i} = 1$$</p>
<p>$$\therefore x_{i+1} - x_{i} = \frac{1}{k}$$</p>
<p>$$\Rightarrow x_{i+1} = x_{i} + \frac{1}{k}$$</p>
<p>这里的 $\frac{1}{k}$ 就是增量，即：$\Delta x = \frac{1}{k}$</p>
<p>另外，需要知道一条边何时不再与下一条扫描线相交，以便及时把它从有效边表里删除出去，避免下一步进行无谓的计算</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13A/04.png" alt="04.png"></p>
<p>为了方便活性边表的建立与更新，需要构造一个新边表（NET），用来存放多边形的边的信息，有四个步骤：</p>
<blockquote>
<p>使用如图的多边形举例：</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13A/05.png" alt="05.png"></p>
<p>1. 构造一个纵向链表，链表的长度为多边形所占有的最大扫描线数，链表的每个节点，称为一个<strong>吊桶</strong>，对应多边形覆盖的每一条扫描线</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13A/06.png" alt="06.png"></p>
<p>2. NET 挂在与该边低端 y 值相同的扫描线桶中，即：存放在该扫描线第一次出现的边</p>
<ul>
<li>该边的 $y_{max}$</li>
<li>该边较低点的 x 坐标值 $x_{min}$</li>
<li>该边的斜率 $\frac{1}{k}$</li>
<li>指向下一条具有相同较低端 y 坐标的边的指针</li>
</ul>
<table>
<thead>
<tr>
<th align="center">$y_{max}$</th>
<th align="center">x_{min}</th>
<th align="center">$\frac{1}{k}$</th>
<th align="center">next</th>
</tr>
</thead>
</table>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13A/07.png" alt="07.png"></p>
<p>通过上面的 NET 表就可以知道多边形是从哪里开始的：在这个表中只有 1、3、5、7 有边存在，而在 1 这条扫描线有两条边进入，所以就把这两条边放进活性边表进行处理</p>
<p>每做一次新的扫描线时，需要对已有的边进行三个处理：</p>
<ol>
<li>判断是否是活性边，不是就除掉</li>
<li>如果没有被除掉，就要对它的数据进行更新，即：更新它的 x 值（$x + \frac{1}{k}$）</li>
<li>判断有没有新的边进入，有新的边进入 NET 表里，可以插入排序</li>
</ol>
<h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1><p>扫描线算法可以实现已知任意多边形区域边界的填充</p>
<p>该填充算法是按照扫描线的顺序，计算扫描线与待填充区域的相交区间，再用要求的颜色显示这些区间里的像素</p>
<p>为了提高算法效率：</p>
<ol>
<li>使用增量的思想</li>
<li>使用连贯性的思想</li>
<li>构建了一套特殊的数据结构</li>
</ol>
<p>这里区间的端点是通过计算扫描线与多边形边界的交点获得的，所以待填充区域的边界线必须是已知的，因此：</p>
<p><strong>X-扫描线算法的缺点是：</strong>无法实现对未知边界的区域进行填充</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>博客错误日志</title>
    <url>/20/04/08B/</url>
    <content><![CDATA[<p>没有简介😮</p>
<a id="more"></a>

<h1 id="1-Hexo-对-和-括起来的内容将被解析，这可能会引发错误"><a href="#1-Hexo-对-和-括起来的内容将被解析，这可能会引发错误" class="headerlink" title="1. Hexo 对 和` 括起来的内容将被解析，这可能会引发错误"></a>1. Hexo 对 {{}} 的解析

> Unhandled rejection Nunjucks Error

Hexo 使用 Nunjucks 渲染文章，被 `{{}}<code>和</code>{%%}` 括起来的内容将被解析，这可能会引发错误</h1><p>比如我使用 LaTeX 写一个字符 $A_{{c}'}$ ==&gt; <code>$A_{{c}'}$</code> 然后 <code>hexo g</code> 出现报错：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr08B/00.png" alt="00.png"></p>
<p>它提示我的第五行，也就是刚刚的字符出错了</p>
<p><strong>如何解决：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 &#123;% raw %&#125; &#123;% endraw %&#125; 将你不希望使用 Nunjucks 解析的内容括起来</span><br><span class="line"></span><br><span class="line">注意：&#123;% raw %&#125; &#123;% endraw %&#125; 在代码块中不会被解析，也就起不了作用，但是代码块中的 &#123;&#123;&#125;&#125; 本身也是不会被解析的</span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">$A_&#123;&#123;c&#125;&#39;&#125;$</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>

<p>最后看看我这部分文字是怎么写的你可能就更清楚了</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr08B/01.png" alt="01.png"></p>
]]></content>
      <categories>
        <category>博客纪要</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>认识算法分析</title>
    <url>/20/04/13B/</url>
    <content><![CDATA[<p>不写简介不是因为懒😐</p>
<a id="more"></a>

<h1 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a>什么是算法？</h1><p>一系列解决问题的清晰指令，能够对一定规范的输入，在有限的时间内获得要求的输出</p>
<p>算法的特点：</p>
<p>1. 指令清晰</p>
<p>指令：计算机中的一行代码</p>
<p>清晰：每一条指令不应该具有二义性，即计算机在接收到这条指令时，它的理解是唯一的</p>
<p>2. 输入规范</p>
<p>算法要有输入，且要确定该算法的输入范围</p>
<p>3. 有限性</p>
<p>算法运行的时间是有限的，只要算法能够终止，它的时间就是有限的</p>
<p>4. 输出</p>
<p>输出是任何一个算法必须的，如果一个算法没有输出，它就没有任何意义</p>
<p>算法描述：同一个算法有不同的表达方式</p>
<ol>
<li>自然语言描述</li>
<li>伪代码描述</li>
</ol>
<p>伪代码对照：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13B/00.png" alt="00.png"></p>
<p>算法是问题的程序化解决方案，因此它遵循一定的流程</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13B/01.png" alt="01.png"></p>
<h1 id="算法分析？"><a href="#算法分析？" class="headerlink" title="算法分析？"></a>算法分析？</h1><p>算法分析就是要分析算法的时间效率和空间效率</p>
<p>时间效率也就是时间复杂度，反映的是算法运行需要的时间长度</p>
<p>空间效率也就是空间复杂度，反映的是算法运行需要的存储空间</p>
<p>算法分析的核心是分析算法的时间效率</p>
<p>输入规模越大的算法，其需要的计算时间就越长，同时也与算法实现的程序设计语言、编译器以及运行算法的硬件设备都有关系</p>
<p>对于输入规模很大的算法，其运行时间通常由算法的操作中那些最耗时的操作来确定</p>
<p>四则运算的算法中，通常乘除运算比加减运算耗时更多</p>
<p>基本操作：用算法中最耗时的操作被执行的次数来度量算法的时间</p>
<p>一个算法的运行时间主要与输入规模和基本操作有关</p>
<p>eg.</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13B/02.png" alt="02.png"></p>
<p>算法的时间效率对于不同的输入是不同的</p>
<h1 id="时间渐进表示"><a href="#时间渐进表示" class="headerlink" title="时间渐进表示"></a>时间渐进表示</h1><p>时间渐进符号：$O$、$\Omega$、$\Theta$</p>
<p>时间效率的渐进表示：</p>
<ul>
<li>$O$</li>
</ul>
<p>对于足够大的 $n$，函数 $t(n)$ 的上界由 $g(n)$ 的常数倍来确定，即：$t(n) \leq c g(n)$，$c$ 为常数，记为：$t(n) \in O (g(n))$</p>
<p>$t(n)$：算法基本操作执行次数的时间多项式，eg. $t(n) = 3n^{2} + 4n + 5$</p>
<p>$g(n)$：常见的效率类型，eg. $log_{n}$、$n$、$nlog_{n}$</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13B/03.png" alt="03.png"></p>
<p>不管 $n$ 如何变化，算法时间多项式的曲线总是在函数 $g(n)$ 的常数倍之下</p>
<p>说明函数 $g(n)$ 对应的效率类型是该算法的下界，即：在最坏情况下，该算法的时间效率为 $O (g(n))$</p>
<ul>
<li>$\Omega$</li>
</ul>
<p>对于足够大的 $n$，函数 $t(n)$ 的下界由 $g(n)$ 的常数倍来确定，即：$t(n) \geq c g(n)$，$c$ 为常数，记为：$t(n) \in \Omega (g(n))$</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13B/04.png" alt="04.png"></p>
<p>不管 $n$ 如何变化，算法时间多项式的曲线总是在函数 $g(n)$ 的常数倍之上</p>
<p>说明函数 $g(n)$ 对应的效率类型是该算法的上界，即：在最优情况下，该算法的时间效率为 $\Omega (g(n))$</p>
<ul>
<li>$\Theta$</li>
</ul>
<p>对于足够大的 $n$，函数 $t(n)$ 的下界和下界由 $g(n)$ 的常数倍来确定，即：$c_{2} g(n) \leq t(n) \leq c_{1} g(n)$，$c_{2}$、$c_{1}$ 为常数，记为：$t(n) \in \Theta (g(n))$</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13B/05.png" alt="05.png"></p>
<p>不管 $n$ 如何变化，算法时间多项式的曲线总是在函数 $g(n)$ 的两个常数倍之间</p>
<p>说明函数 $g(n)$ 对应的效率类型是该算法的上界和下界之间，即：在典型输入下，该算法的时间效率为 $\Theta (g(n))$</p>
<p>eg. 算法 1 的时间多项式：$t_{1}(n) = 2n^{2} + 4n + 20$，算法 2 的时间多项式：$t_{2}(n) = 10nlog_{n} + 5n + 3$，问：哪一个算法的效率更高</p>
<p>$\because t_{1}(n) \in \Omega (n^{2}),;t_{2}(n) \in \Omega (nlog_{n})$</p>
<p>$\therefore$ 算法 2 效率更高</p>
<p><strong>定理：</strong></p>
<p>如果：$t_{1}(n) \in O(g_{1}(n))$ 且 $t_{2}(n) \in O(g_{2}(n))$，则 $t_{1}(n) + t_{2}(n) \in O(max \left{ g_{1}(n),;g_{2}(n) \right} )$</p>
<p>算法的基本效率类型：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr13B/06.png" alt="06.png"></p>
<p>如果算法的时间效率属于 $n^3$ 以上时，在输入规模 $n$ 逐渐增大的时候，这类算法的时间消耗增速很快，因此，要尽可能将设计算法的时间效率保证在 $n^3$ 以下</p>
<h1 id="非递归算法效率分析"><a href="#非递归算法效率分析" class="headerlink" title="非递归算法效率分析"></a>非递归算法效率分析</h1><p>eg.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法 MaxElement(A[0,1,...,n-1])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 求出给定数组中的最大元素</span><br><span class="line">&#x2F;&#x2F; 输入：实数数组 A[0,1,...,n-1]</span><br><span class="line">&#x2F;&#x2F; 输出：A 中的最大元素</span><br><span class="line"></span><br><span class="line">maxval ⬅ A[0]</span><br><span class="line">for i ⬅ 1 to n-1 do</span><br><span class="line">    if A[i] &gt; maxval</span><br><span class="line">        maxval ⬅ A[i]</span><br><span class="line">return maxval</span><br></pre></td></tr></table></figure>

<p>输入规模：数组长度 n</p>
<p>基本操作：比较运算</p>
<p>算法的效率：$C(n) = \sum_{i=1}^{n-1}1 = n-1 \in \Theta (n)$</p>
<p>非递归算法分析通用方案：</p>
<ol>
<li>决定用那些参数作为输入规模的度量</li>
<li>找出算法的基本操作</li>
<li>检查基本操作的执行次数是否只依赖输入规模</li>
<li>建立一个算法基本操作执行次数的求和表达式</li>
<li>利用求和运算的标准公式和法则来建立一个操作次数的闭合公式，或者至少确定它的增长次数</li>
</ol>
<p>eg.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法 UniqueElements(A[0,1,...,n-1])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 验证给定数组的元素是否全部唯一</span><br><span class="line">&#x2F;&#x2F; 输入：实数数组 A[0,1,...,n-1]</span><br><span class="line">&#x2F;&#x2F; 输出：如果唯一，返回 True，否则 False</span><br><span class="line"></span><br><span class="line">for i ⬅ 0 to n-2 do</span><br><span class="line">    for j ⬅ i+1 to n-1 do</span><br><span class="line">        if A[i] &#x3D; A[j] return False</span><br><span class="line">return True</span><br></pre></td></tr></table></figure>

<p>输入规模：数组个数 n</p>
<p>基本操作：比较运算</p>
<p>算法的效率：$C(n) = \sum_{i=0}^{n-2} \sum_{j=i+1}^{n-1} 1 = \sum_{i=0}^{n-2} (n-i-1) = \frac{n(n-1)}{2}$</p>
<p>该算法最坏情况：$O(n^2)$</p>
<p>该算法最好情况：$\Omega (1)$</p>
<p>一般情况下：需要考虑数组中各种元素出现的情况，很难使用数学表达，因此很难确定一个具体的时间表达式，但从最坏的情况来看，该算法的时间上界为：$O (n^2)$</p>
<p><strong>结论：</strong></p>
<p>如果一个算法在执行过程中会根据条件终止，那么该算法会存在最优效率和最差效率，这时选择的时间渐进符号为：$\Omega$ 和 $O$，否则选择符号 $\Theta$</p>
<h1 id="递归算法效率分析"><a href="#递归算法效率分析" class="headerlink" title="递归算法效率分析"></a>递归算法效率分析</h1><p>eg.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法 F(n)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归计算 n!</span><br><span class="line">&#x2F;&#x2F; 输入：非负整数 n</span><br><span class="line">&#x2F;&#x2F; 输出：n! 的值</span><br><span class="line"></span><br><span class="line">if n&#x3D;0 return 1</span><br><span class="line">else return F(n-1)*n</span><br></pre></td></tr></table></figure>

<p>输入规模：n</p>
<p>基本操作：乘法</p>
<blockquote>
<p>只有在递归调用的过程中才会多次执行基本操作</p>
</blockquote>
<p>递归算法很难通过递归调用确定执行次数，但是可以根据递归调用的式子获取基本操作执行次数的递推式和初始条件，通过递推式的计算，得出递归算法的时间多项式</p>
<p>假设 M(n) 是输入规模为 n 时基本操作的执行次数，而在递归调用中的输入规模是 n-1，则递归调用过程中的基本操作执行次数可用 M(n-1) 来表示，M(n) 和 M(n-1) 之间刚好相差了 1 次乘法，即在递归调用中的乘法</p>
<p>基本操作执行次数递推式 $\Rightarrow$ $M(n) = \left{\begin{matrix} M(n-1)+1 , ; n \geq 1 \ ;;;;;;;;;;;;;0;;;;;;;; ,; n=0 \end{matrix}\right.$</p>
<p>$\Rightarrow$ $M(n) = M(n-1)+1$ </p>
<p>$= [M(n-2)+1]+1 = M(n-2)+2$</p>
<p>$……$</p>
<p>$=[M(n-n)+1]+n-1=n$</p>
<p>递归算法分析通用方案</p>
<ol>
<li>决定用哪个参数作为输入规模的度量</li>
<li>找出算法的基本操作</li>
<li>检査对相同规模的输入，基本操作的执行次数是否相同，如果不同，必须对最差、平均及最优效率单独研究</li>
<li>建立一个递推关系式及相应的初始条件</li>
<li>求解这个递归关系式，或者至少确定解的增长次数</li>
</ol>
]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>区域填充算法</title>
    <url>/20/04/15A/</url>
    <content><![CDATA[<p>没有简介又怎么了😏</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>区域：</strong> 👉已经表示成点阵形式的填充图形，是像素的集合</p>
<p>区域填充是指将区域内的一点（通常称为种子点）赋予给定的颜色，然后将这种颜色扩展到整个区域内的过程</p>
<p>区域可以采用<strong>内点</strong>表示和<strong>边界</strong>表示两种形式</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr15A/00.png" alt="00.png"></p>
<p><strong>内点表示：</strong> 枚举出区域内部的所有像素，内部的所有像素填充同一个颜色，边界像素填充与内部像素不同的颜色</p>
<p><strong>边界表示：</strong> 枚举出边界上的所有像素，边界上的所有像素填充同一个颜色，内部像素填充与边界像素不同的颜色</p>
<p>区域填充算法要求<strong>区域是连通</strong>的，因为只有在连通的区域中，才可能将种子点的颜色扩展到区域内的其他点</p>
<p>区域又分为 4 向连通区域和 8 向连通区域</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr15A/01.png" alt="01.png"></p>
<ul>
<li>4 向连通区域：从区域上一点出发，可以通过四个方向，即：👆、👇、👈、👉移动的组合，在不越出区域的前提下，到达区域内任意像素</li>
<li>8 向连通区域：同理</li>
</ul>
<h1 id="简单-4-连通种子填充算法"><a href="#简单-4-连通种子填充算法" class="headerlink" title="简单 4 连通种子填充算法"></a>简单 4 连通种子填充算法</h1><blockquote>
<p>又称：区域填充递归算法</p>
</blockquote>
<p>假设区域采用边界定义，即：区域边界上所有像素均具有某一特定值，区域内部所有像素均不采用这一特定值，而边界外的像素可以具有与边界相同的值</p>
<p>使用<strong>栈结构</strong>来实现简单的种子填充算法</p>
<blockquote>
<p>队列：先进先出<br>栈：后进先出</p>
</blockquote>
<p><strong>算法原理：</strong></p>
<p>种子像素入栈，当栈非空时，重复执行：</p>
<ol>
<li>栈顶像素出栈</li>
<li>将出栈像素填充成要求的颜色</li>
<li>按照👈、👆、👉、👇的顺序（顺序不是固定的）检查与栈像素相邻的四个像素，若其中某个像素不在边界且颜色不是要求的颜色，则将其入栈</li>
</ol>
<p><strong>不足之处：</strong></p>
<ol>
<li>有些像素会入栈多次，降低算法效率</li>
<li>栈结构占空间</li>
<li>递归执行，算法简单，但是效率不高</li>
<li>区域内每一像素都要引进一次递归，进栈出栈，费时费内存</li>
</ol>
<p><strong>改进算法：</strong></p>
<blockquote>
<p>减少递归次数，提高效率</p>
</blockquote>
<p>可以采用区域填充的扫描线算法</p>
<h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1><p>多边形扫描转换：</p>
<ul>
<li>将多边形的顶点表示转化为点阵表示</li>
<li>从多边形的边界（顶点）信息出发，利用多种形式的连贯性进行填充</li>
</ul>
<p>区域填充：</p>
<ul>
<li>只改变区域颜色，不改变区域表示方法</li>
<li>要求给定区域内一点作为种子点，然后从种子点根据连通性将新的颜色扩散到整个区域</li>
</ul>
<p>区域填充的核心是要知道多边形的边界，得到内部的像素集，所以条件性更强</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>直线段扫描转换算法</title>
    <url>/20/04/08A/</url>
    <content><![CDATA[<p>数学里的直线上的点是无穷多的，但是光栅显示器的像素点是有限的，所以只能使用有限的像素去尽可能逼近直线</p>
<a id="more"></a>

<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr08A/00.png" alt="00.png"></p>
<p>为了在光栅显示器上用这些离散的像素点去逼近直线，需要知道这些像素点的 $x$, $y$ 坐标</p>
<p><strong>求法：</strong></p>
<p>1. 求出过点 $P_{0}$, $P_{1}$ 的直线段的方程：</p>
<p>$$y = kx + b$$</p>
<p>$$k=\frac{ \left ( y_{1} - y_{0}\right ) }{ \left ( x_{1} - x_{0}\right ) } ;;; \left ( x_{1} \neq x_{0}\right )$$</p>
<p>2. 求 $y$ 的值</p>
<p>假设 $x$ 已知，即从 $x$ 的起点 $x_{0}$ 开始，沿着 $x$ 方向前进一个像素（步长 = 1），可以计算出相应的 $y$ 值</p>
<p>因为像素的坐标是整数，所以 $y$ 值还需要进行取整处理</p>
<p>取整规律：</p>
<p>$$P\left(1.7,;0.8\right) \rightarrow \left(+0.5\right)  \rightarrow 取整 \rightarrow P\left(2,;1\right)$$</p>
<p>直线是最基本的图形，一个动画或者真实感图形往往需要调用成千上万次画线程序，因此直线算法的好坏与效率将直接影响图形的质量和显示速度</p>
<p>算法优化：把算法中的乘法消去可以减少计算量，从而提高算法效率</p>
<p><strong>三个直线绘制常用算法：</strong></p>
<ol>
<li>数值微分法（DDA）</li>
<li>中点画线法</li>
<li>Bresenham 算法</li>
</ol>
<h1 id="1-数值微分法"><a href="#1-数值微分法" class="headerlink" title="1. 数值微分法"></a>1. 数值微分法</h1><blockquote>
<p>引进了增量思想，算法直观、容易实现</p>
</blockquote>
<p><strong>原理解析：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr08A/01.png" alt="01.png"></p>
<p>在上图中点 $\left(x_{i},;y_{i}\right)$, $\left(x_{i+1},;y_{i+1}\right)$ 可以表示为：</p>
<p>$$y_{i} = kx_{i} + b$$</p>
<p>$$y_{i+1} = kx_{i+1} + b$$</p>
<p>因为存在假设：$x$ 已知，且每次前进步长为 1，所以：$x_{i+1} = x_{i} + 1$ </p>
<p>则：</p>
<p>$$y_{i+1} = kx_{i+1} + b$$</p>
<p>$$;;;;;;;;;;;;; = k \left(x_{i} + 1\right) + b$$</p>
<p>$$;;;;;;;;;;= kx_{i} + k + b$$</p>
<p>$$;;;;;;;;;;= kx_{i} + b + k$$</p>
<p>$$;;= y_{i} + k$$</p>
<p>即：当前的 $y$ 值等于前一步的 $y$ 值 + 斜率 $k$</p>
<p>这里的斜率 $k$ 也就是式子 $y_{i+1} = y_{i} + k$ 的增量</p>
<p>这样就把原来一个乘法和加法变成了一个加法</p>
<p>eg. 用 DDA 扫描转换连接两点 $P_{0} \left(0,;0\right)$ 和 $P_{1} \left(5,;3\right)$ 的直线段</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr08A/02.png" alt="02.png"></p>
<p>1. 计算 $k$</p>
<p>$$k = \frac{y_{1} - y_{0}}{x_{1} - x_{0}} = \frac{3 - 0}{5 - 0} = 0.6 &lt; 1$$</p>
<p>2. 计算像素点坐标</p>
<table>
<thead>
<tr>
<th align="center">$x$</th>
<th align="center">$y$</th>
<th align="center">$int \left(y + 0.5\right)$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$0$</td>
<td align="center">$0$</td>
<td align="center">$0$</td>
</tr>
<tr>
<td align="center">$1$</td>
<td align="center">$0+0.6$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$2$</td>
<td align="center">$0.6+0.6$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$3$</td>
<td align="center">$1.2+0.6$</td>
<td align="center">$2$</td>
</tr>
<tr>
<td align="center">$4$</td>
<td align="center">$1.8+0.6$</td>
<td align="center">$2$</td>
</tr>
<tr>
<td align="center">$5$</td>
<td align="center">$2.4+0.6$</td>
<td align="center">$3$</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr08A/03.png" alt="03.png"></p>
<p><strong>注意：</strong></p>
<p>当 $|k| &gt; 1$ 时</p>
<p>使用上述计算方式可能不能画出直线，因为任意两点之间通过 DDA 算法计算直线，当 $|k| &gt; 1$ 时，结果只有三个点，如果两点之间距离比较远，就会导致光栅点太稀疏，从而不能描绘直线</p>
<h1 id="2-中点画线法"><a href="#2-中点画线法" class="headerlink" title="2. 中点画线法"></a>2. 中点画线法</h1><p>对 DDA 的改进方案：</p>
<p>1. 提高算法效率</p>
<p>$$y_{i+1} = y_{i} + k$$</p>
<p>因为在计算机中，加法运算是最快的，加法运算里整数加法又是最快的</p>
<p>一般情况下，$y$ 和 $k$ 都是小数，而且每一步运算都要对 $y$ 进行四舍五入后取整，所以可以通过把浮点运算变成整数运算来改进</p>
<p>2. 改变直线方程类型</p>
<p>中点画线法：利用直线的一般式方程</p>
<p>$$F \left(x,;y\right) = 0$$</p>
<p>$$Ax + By + C = 0 ;;;\left(其中：A = - \left(\Delta y\right); ;; B = \left(\Delta x\right); ;; C = - B \left(\Delta x\right)\right)$$</p>
<p>这样一来，对于直线上的点：$F \left(x,;y\right) = 0$</p>
<p>对于直线上方的点：$F \left(x,;y\right) &gt; 0$</p>
<p>对于直线下方的点：$F \left(x,;y\right) &lt; 0$</p>
<p><strong>原理解析：</strong></p>
<p>每一次在最大位移方向上走一步，而另一个方向走不走取决于中点误差项的判断</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr08A/04.png" alt="04.png"></p>
<p>假设：$0 \leq |k| \leq 1$，所以每次在 $x$ 方向上 $+1$，$y$ 方向上的变化情况需要通过判断 $P_{u}$ 到 $P_{d}$ 的中点来决定</p>
<p>如图，此时 <code>ideal line</code> 与直线 $P_{u}P_{d}$ 有一个交点 $Q$，直线 $P_{u}P_{d}$ 有一个中点：$M \left(x_{i}+1,;y_{i}+0.5\right)$</p>
<p>判断：</p>
<ul>
<li>当 $Q$ 在 $M$ 上方时，$P_{u}$ 距离直线更近，则 $P_{u}$ 为下一像素点</li>
<li>当 $Q$ 在 $M$ 下方时，$P_{d}$ 距离直线更近，则 $P_{d}$ 为下一像素点</li>
<li>若 $Q$ 和 $M$ 是同一个点，则 $P_{u}$ 或 $P_{d}$ 都可以是下一像素点</li>
</ul>
<p><strong>如何判断 $Q$ 在 $M$ 上方还是下方？</strong></p>
<p>1. 把 $M$ 代入理想直线方程：</p>
<p>$$F \left(x_{m},;y_{m}\right) = Ax_{m} + By_{m} + C$$</p>
<p>$$令：d = F \left(x_{m},;y_{m}\right) = F \left(x_{i} + 1,;y_{i} + 0.5\right)$$</p>
<p>$$;;= A \left(x_{i}+1\right) + B \left(y_{i} + 0.5\right) + C$$</p>
<p>2. 判断</p>
<ul>
<li>当 $d &lt; 0$ 时：$Q$ 在 $M$ 上方，下一像素点为 $P_{u}$</li>
<li>当 $d &gt; 0$ 时：$Q$ 在 $M$ 下方，下一像素点为 $P_{d}$</li>
<li>当 $d = 0$ 时：$Q$ 等于 $M$，下一像素点为 $P_{u}$ 或 $P_{d}$ 都可以</li>
</ul>
<p>算法：</p>
<p>$$y = \left{\begin{matrix} y+1 &amp; \left(d &lt; 0\right) \ y &amp; \left(d \geq 0 \right) \end{matrix}\right.$$</p>
<p>算法计算量：为了求得 $d$ 值，需要 $4$ 个乘法，$2$ 个加法</p>
<p>对中点画线法的改进：因为 $d$ 是 $x$, $y$ 的线性函数，所以可以采用增量计算</p>
<p><strong>推导过程：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr08A/05.png" alt="05.png"></p>
<p>代入中点坐标求得 $d_{0}$：</p>
<p>$$d_{0} = F \left(x_{m0},;y_{m0}\right)$$</p>
<p>$$;;;;;;;;;;;;;;= F \left(x_{i}+1,;y_{i}+0.5\right)$$</p>
<p>$$;;;;;;;;;;;;;;;;;;;;;;;;;;;;; = A \left(x_{i}+1\right) + B \left(y_{i}+0.5\right) + C$$</p>
<p><strong>假设 $d &lt; 0$</strong></p>
<p>则第一个取的像素点 $P_{0}$ 为 $P_{u} \left(x_{i} + 1,;y_{i} + 1\right)$</p>
<p>再往下计算一个像素点 $P_{1}$ 的位置：</p>
<p>则 $P_{1}$ 可能是点 $P_{a} \left(x_{i}+2,;y_{i}+1\right)$ 或者 $P_{b} \left(x_{i}+2,;y_{i}+2\right)$</p>
<p>则直线 $P_{a}P_{b}$ 的中点为 $M_{1} \left(x_{i}+2,;y_{i}+1.5\right)$</p>
<p>所以：</p>
<p>$$d_{1} = F \left(x_{m1},;y_{m1}\right)$$</p>
<p>$$;;;;;;;;;;;;;;; = F \left(x_{i}+2,;y_{i}+1.5\right)$$</p>
<p>$$;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; = A\left(x_{i}+2\right) + B\left(y_{i}+1.5\right) + C$$</p>
<p>$$;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; = A\left(x_{i}+1\right) + B\left(y_{i}+0.5\right) + C + A + B$$</p>
<p>$$;;;= d_{0} + A + B$$</p>
<p><strong>假设 $d \geq 0$</strong></p>
<p>则第一个取的像素点 $P_{0}’$ 为 $P_{d} \left(x_{i} + 1,;y_{i}\right)$</p>
<p>再往下计算一个像素点 $P_{1}’$ 的位置：</p>
<p>则 $P_{1}’$ 可能是点 $P_{a} \left(x_{i}+2,;y_{i}+1\right)$ 或者 $P_{c} \left(x_{i}+2,;y_{i}\right)$</p>
<p>则直线 $P_{a}P_{c}$ 的中点为 $M_{1}’ \left(x_{i}+2,;y_{i}+0.5\right)$</p>
<p>所以：</p>

$$d_{1} = F \left(x_{{m1}'},\;y_{{m1}'}\right)$$


<p>$$;;;;;;;;;;;;; = F \left(x_{i}+2,;y_{i}+0.5\right)$$</p>
<p>$$;;;;;;;;;;;;;;;;;;;;;;;;;;;; = A\left(x_{i}+2\right) + B\left(y_{i}+0.5\right) + C$$</p>
<p>$$;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; = A\left(x_{i}+1\right) + B\left(y_{i}+0.5\right) + C + A$$</p>
<p>$$= d_{0} + A ;;;;;$$</p>
<p><strong>计算 $d_{0}$：</strong></p>
<p>直线的第一个像素点坐标为：$P\left(x_{0},;y_{0}\right)$</p>
<p>$$d_{0} = F \left(x_{0}+1,;y_{0}+0.5\right)$$</p>
<p>$$;;;;;;;;;;;;;;;;;;;; = A \left(x_{0}+1\right) + B \left(y_{0}+0.5\right) + C$$</p>
<p>$$;;;;;;;;;;;;;;;;; = Ax_{0} + By_{0} + C + A + 0.5B$$</p>
<p>因为 $P \left(x_{0},;y_{0}\right)$ 在直线上，所以满足 $Ax_{0} + By_{0} + C = 0$</p>
<p>所以：</p>
<p>$$d_{0} = A + 0.5B$$</p>
<p><strong>中点画线法算法：</strong></p>
<p>$$d_{new} = \left{\begin{matrix} d_{old} + A + B &amp; \left(d &lt; 0\right) \ d_{old} + A &amp; \left(d \geq 0\right) \end{matrix}\right. ;;; d_{0} = A + 0.5B$$</p>
<p>至此，中点画线法算法与 DDA 的算法效率一样好</p>
<p><strong>注意：</strong></p>
<p>一般情况下，$A$、$B$ 都是整数，而 $d_{0}$ 的计算中存在浮点数，浮点数的运算更复杂</p>
<p>但是 $d_{0}$ 的作用只是与 $0$ 比较大小，所以完全可以用 $2d_{0}$ 代替 $d_{0}$，以此可以避免浮点数运算</p>
<p>此时中点画线法算法中只包含整数运算，所以更优于 DDA 算法</p>
<h1 id="3-Bresenham-算法"><a href="#3-Bresenham-算法" class="headerlink" title="3. Bresenham 算法"></a>3. Bresenham 算法</h1><p>Bresenham 拥有更优的效率和更广泛的适用范围</p>
<p><strong>基本思想：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr08A/06.png" alt="06.png"></p>
<p>通过各行、各列像素中心构造一组虚拟网格线，按照直线起点到终点的顺序，计算直线与各垂直网格线的交点，然后根据误差项（交点距离像素点的距离）的符号确定该列像素中与此交点最近的像素</p>
<p>假设每次 $x+1$，$y$ 的递增（减）量为 $0$ 或 $1$，它取决于实际直线与光栅网格点的距离，这个距离的最大误差是 $0.5$</p>
<ul>
<li>如果 $d &lt; 0.5$，$y$ 的递增（减）量为 $0$</li>
<li>如果 $d &gt; 0.5$，$y$ 的递增（减）量为 $1$</li>
<li>如果 $d = 0.5$，$y$ 的递增（减）量为 $0$ 或 $1$ 中任意一个</li>
</ul>
<p>误差项 $d$ 的初值 $d_{0} = 0$</p>
<p>初始之后的 $d = d + k$</p>
<p>一旦 $d \geq 1$，就将其减 $1$，以保证 $d$ 的相对性，且始终在 $0$、$1$ 之间</p>
<p>计算下一个象素点的原理：</p>
<p>$$P_{next = }\left{\begin{matrix} x_{i+1} = x_{i} + 1 \ y_{i+1} = \left{\begin{matrix} y_{i} + 1 &amp; \left(d &gt; 0.5\right) \ y_{i} &amp; \left(d \leq 0.5\right) \end{matrix}\right. \end{matrix}\right.$$</p>
<p><strong>算法效率优化：</strong></p>
<p>1. 令 $e = d - 0.5$</p>
<p>将值的大小替换成正负号</p>
<p>$$P_{next = }\left{\begin{matrix} x_{i+1} = x_{i} + 1 \ y_{i+1} = \left{\begin{matrix} y_{i} + 1 &amp; \left(e &gt; 0\right) \ y_{i} &amp; \left(e \leq 0\right) \end{matrix}\right. \end{matrix}\right.$$</p>
<ul>
<li>$e_{初} = -0.5$</li>
<li>每当 $x + 1$，则 $e = e + k$</li>
<li>如果 $e &gt; 0$，则 $e = e - 1$</li>
</ul>
<p>2. 令 $2e\Delta x = e$</p>
<p>因为 $k = \frac{dy}{dx}$、$dx = \Delta x$</p>
<ul>
<li>$e_{初} = -\Delta x$</li>
<li>每当 $x + 1$，则 $e = e + 2\Delta y$</li>
<li>如果 $e &gt; 0$，则 $e = e - 2\Delta x$</li>
</ul>
<p>至此，算法全部改进为整数加法，且不受直线方程类型的限制</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li>输入直线的两端点 $P_{0}\left(x_{0},;y_{0}\right)$ 和 $P_{1}\left(x_{1},;y_{1}\right)$</li>
<li>计算初始值 $\Delta x$、$\Delta y$、$e = -\Delta x$、$x = x_{0}$、$y = y_{0}$</li>
<li>绘制点 $\left(x,;y\right)$</li>
<li>将 $e$ 替换为 $e + 2\Delta y$，判断 $e$ 的符号<ul>
<li>若 $e &gt; 0$，则将 $\left(x,;y\right)$ 替换为 $\left(x+1,;y+1\right)$，同时将 $e$ 替换为 $e - 2\Delta y$</li>
<li>否则，将 $\left(x,;y\right)$ 替换为 $\left(x+1,;y\right)$</li>
</ul>
</li>
<li>当直线没有画完时，重复步骤 3 和 4，否则结束</li>
</ol>
<blockquote>
<p>Bresenham 算法很像 DDA 算法，都是加斜率，但 DDA 算法是每次求出一个新的 $y$ 以后取整来画，而 Bresenham 算法是判符号来决定上下两个点，所以该算法集中了 DDA 和中点算法的优点，而且应用范围更广泛</p>
</blockquote>
<h1 id="4-结"><a href="#4-结" class="headerlink" title="4. 结"></a>4. 结</h1><p>以上是基础原理，实现代码🕳</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>反走样算法</title>
    <url>/20/04/16A/</url>
    <content><![CDATA[<p>日常不写简介😓</p>
<a id="more"></a>

<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr16A/06.png" alt="06.png"></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>对于直线、圆以及椭圆这些最基本元素的生成速度和显示质量的改进，在图形处理系统种具有重要的应用价值</p>
</blockquote>
<p>但是它们生成的线条具有明显的“锯齿形”，即：发生走样现象</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr16A/00.png" alt="00.png"></p>
<p>“锯齿”是走样的一种形式，而走样是光栅显示的一种固有性质，产生走样现象的原因是像素本质上的离散性</p>
<p><strong>走样是数字化的必然产物</strong></p>
<p>走样现象：</p>
<ul>
<li>光栅图形产生的阶梯形（锯齿形）</li>
<li>图形中包含相对微小的物体的时候，这些物体在静态图形中容易被丢弃或忽略，在动画序列中时隐时现，产生闪烁</li>
</ul>
<p>如果对一个快速变化的信号采样频率过低，所得到的样本表示的会是低频变化的信号，原始信号的频率看起来被较低的走样频率所代替</p>
<h1 id="反走样技术"><a href="#反走样技术" class="headerlink" title="反走样技术"></a>反走样技术</h1><p>用于减少或者消除走样效果的技术叫做反走样技术</p>
<p>由于图形的走样现象对于图形的显示质量影响很大，几乎所有的图形处理系统都要对基本图形进行反走样处理</p>
<p>采用分辨率更高的显示设备，对解决走样现象有所帮助，因为可以使锯齿相对物体会更小一些</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr16A/01.png" alt="01.png"></p>
<p>但是这样的反走样方法是以成倍的存储器代价和扫描转换时间为代价获得的</p>
<p>为了稳定屏幕上的图像，电子枪至少要以 $\frac{1}{24}$ 秒 1 次的速度轰击屏幕上的所有像素，如果像素提高一倍，电子枪轰击的速度就要提高 4 倍</p>
<p>反走样技术涉及到某种形式的“模糊”来产生更加平滑的图像</p>
<p>eg. 对于在白色背景中的黑色矩形，可以通过在矩形的边界附近添加一些灰色像素，可以柔化由黑色👉白色的尖锐的变化，从远处观察这幅图像时，人眼能够把这些缓和变化的暗影融合在一起，从而感知到更加平滑的边界</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr16A/02.png" alt="02.png"></p>
<p>两种反走样方法：</p>
<ol>
<li>非加权区域采样法</li>
<li>加权区域采样法</li>
</ol>
<h1 id="非加权区域采样法"><a href="#非加权区域采样法" class="headerlink" title="非加权区域采样法"></a>非加权区域采样法</h1><p>根据物体的覆盖率计算像素的颜色，覆盖率是指某个像素区域被物体覆盖的比例</p>
<p>eg.</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr16A/03.png" alt="03.png"></p>
<p>把一个多边形放在方格之中，其中每个小正方形的中心对应显示器上的像素中心，被多边形覆盖了一半的像素亮度赋值为 $\frac{1}{2}$，覆盖了三分之一的像素亮度赋值为 $\frac{1}{3}$，以此类推</p>
<p>如果这时缓冲区的每个像素有 4bit，那么 0👉15 表示颜色由 黑色👉白色</p>
<p>非加权区域采样法的缺点：</p>
<ul>
<li>像素的亮度与相交区域的面积是呈正比的，而与相交区域落在像素内的位置无关，这样依然会产生锯齿效应</li>
<li>直线条上沿理想直线方向的相邻的两个像素有时会有较大的灰度差</li>
</ul>
<p>造成这些缺点的主要原因是因为每个像素的权值一样</p>
<h1 id="加权区域采样法"><a href="#加权区域采样法" class="headerlink" title="加权区域采样法"></a>加权区域采样法</h1><p>这种方法的反走样效果更好，其更符合人的视觉系统对于图像信息的处理方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr16A/04.png" alt="04.png"></p>
<p>将直线段看作是具有一定宽度的狭长矩形，当直线段与像素相交时，根据相交区域与像素中心的距离来决定其对像素亮度的影响</p>
<p>直线段对于一个像素亮度的影响与相交区域到像素中心的距离成正比</p>
<p>离像素中心越近，显示的亮度越亮</p>
<p>则通过设置相交区域面积与像素中心距离的权函数（高斯函数），可以反映相交面积对于整个像素亮度的影响大小</p>
<p>利用权函数积分求相交区域面积，用它乘以像素可以设置的最大亮度值，即可以得到该像素实际显示的亮度值</p>
<p>为了简化计算，一般采用离散计算方法</p>
<p>eg.</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr16A/05.png" alt="05.png"></p>
<p>将一个像素划分为 $n = 3 \times 3$ 个子像素，加权表可以取作：</p>
<p>$$\begin{bmatrix} w1 &amp; w2 &amp; w3 \ w4 &amp; w5 &amp; w6 \ w7 &amp; w8 &amp; w9 \end{bmatrix} = \begin{bmatrix} 1 &amp; 2 &amp; 1 \ 2 &amp; 4 &amp; 2 \ 1 &amp; 2 &amp; 1 \end{bmatrix}$$</p>
<p><strong>加权方案：</strong> 中心子像素的加权时角子像素的 4 倍，是其他像素的 2 倍，对 9 个子像素的每个网格计算出的亮度进行平均</p>
<p>然后求出所有中心落于直线段内的子像素</p>
<p>最后计算所有这些子像素对原像素亮度影响之和</p>
<blockquote>
<p>反走样是图形学中的一个根本问题，是不可能避免的，是图形学中的一个永恒问题</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>减治法与排序</title>
    <url>/20/04/29A/</url>
    <content><![CDATA[<blockquote>
<p>减治法利用了一个问题给定的实例的解和同样问题较小实例的解之间的关系，从较小实例出发，利用迭代，或者从较大的实例出发，利用递归，从而求解</p>
</blockquote>
<ul>
<li>减常量形式</li>
<li>减常因子形式</li>
<li>减可变因子形式</li>
</ul>
<a id="more"></a>

<p>减一技术：问题的较小实例与较大实例的规模相差一个常数，通常这个常数为：1</p>
<h1 id="减常量形式"><a href="#减常量形式" class="headerlink" title="减常量形式"></a>减常量形式</h1><h2 id="eg-插入排序"><a href="#eg-插入排序" class="headerlink" title="eg. 插入排序"></a>eg. 插入排序</h2><p>对一个包含 N 个元素的数组进行排序</p>
<p>假设这个数组的较小规模包含 N-1 个元素的子数组已经按照从小到大的顺序进行排序，则此时求解即求解如何将第 N 个元素也加入数组，使得这 N 个元素是有序的？</p>
<p>即：将第 N 个元素插入已经有序的数组中，使得最终的数组有序</p>
<p>可以从右到左扫描已经有序的子数组：</p>
<ul>
<li><p>如果扫描到的元素比第 N 个元素大，那么插入的位置至少应该在扫描元素之前，那么就让扫描元素向右覆盖，将第 N 个元素插入当前扫描位置，然后继续扫描</p>
</li>
<li><p>如果扫描到的元素比第 N 个元素小，那么就应该结束扫描，将第 N 个元素插入当前扫描位置之后一个的位置</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InsertSort(A[0, ..., n-1])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用插入排序对给定数组排序</span><br><span class="line">&#x2F;&#x2F; 输入：一个可排序的数组 A</span><br><span class="line">&#x2F;&#x2F; 输出：非降序排列数组 A</span><br><span class="line"></span><br><span class="line">for i⬅1 to n-1 do &#123;</span><br><span class="line">    v ⬅ A[i];</span><br><span class="line">    j ⬅ i-1;</span><br><span class="line">    while(j&gt;&#x3D;0 and A[j]&gt;v) &#123;</span><br><span class="line">        A[j+1] ⬅ A[j];</span><br><span class="line">        j ⬅ i-1;</span><br><span class="line">    &#125;</span><br><span class="line">    A[j+1] ⬅ v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析：</p>
<ul>
<li>基本操作：子数组扫描</li>
</ul>
<p>最坏情况：数组是从大到小排序的</p>
<p>$$C_{worst}(n) = \sum_{i=1}^{n-1} \sum_{j=0}^{i-1} = \sum_{i=1}^{n-1}i = \frac{(n-1)n}{2} \in \Theta (n^2)$$</p>
<p>最好情况：数组是从小到大排序的</p>
<p>$$C_{best}(n) = \sum_{i=1}^{n-1}1 = n-1 \in \Theta (n)$$</p>
<p>随机排序的数组</p>
<p>$$C_{avg}(n) \approx \frac{n^2}{4} \in \Theta (n^2)$$</p>
<p>平均比较次数是最坏情况的一半：$\frac{n^2}{4 }$</p>
<h2 id="eg-生成组合对象"><a href="#eg-生成组合对象" class="headerlink" title="eg. 生成组合对象"></a>eg. 生成组合对象</h2><p>旅行商问题：需要生成包含所有城市的所有排列</p>
<p>eg. 集合 (1, 2, 3) 的排列有 6 个，分别为：123，132，213，231，312，321</p>
<p>用减一法的思路来解决对 n 个元素生成排列的问题：</p>
<p>假设生成较小规模的集合 {1, …, n-1} 的全部 (n-1)! 个排列的问题已经解决，我们只需要把 n 插入到每个排列的 n 个可能的位置中去，问题就可以解决，由于每个排列插入 n 之后，是 n 个不同的排列，原始问题的排列数则为：n(n-1)!，即：n!</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr29A/00.png" alt="00.png"></p>
<p><strong>满足最小变化要求：</strong> 假设插入第一个排列时从右到左，插入下一个排列时从左到右，得到的排列中相邻两个只有两个元素是不同的，这样交换相邻排列中的两个元素就可以得到一个新的排列</p>
<p>缺点：</p>
<p>需要保存 n-1 规模子集的全部排列，才能产生出 n 规模自己的排列，比较浪费存储空间</p>
<p>改进：</p>
<p>Johnson-Trotter 算法：从原始排列开始，通过交换排列中某两个相邻的元素来产生一个新的排列，如此生成全部排列</p>
<p>规定排列中每个元素都有一个方向，我们在元素上画一个箭头，箭头指向元素移动的方向，如果箭头指向一个相邻的较小的元素，则称该元素是可移动的，如果一个元素在排列的左端，箭头方向也向左，或者一个元素在排列的右端，箭头方向也向右，则称该元素是不可移动的</p>
<p>步骤：</p>
<ol>
<li>初始化排列为：1, 2, 3, …, n，每个元素的方向向左；</li>
<li>如果排列中存在可移动元素，执行步骤 3，否则退出；</li>
<li>在排列中找出最大的可移动元素；</li>
<li>将该元素与其所指向的元素进行交换；</li>
<li>调换所有大于该元素的元素的方向；</li>
<li>输出交换元素之后的排列，返回步骤 2。</li>
</ol>
<p>由于该算法的运行时间与排列数量成正比，所以其时间复杂度为：n!</p>
<p>缺点：生成的排列次序不是字典序</p>
<p>改进：算法 LexicographicPermute</p>
<p>以字典许生成排列的步骤：</p>
<ol>
<li>初始化排列为：1, 2, 3, …, n；</li>
<li>如果排列中有两个连续升序的元素，则执行步骤 3，否则退出；</li>
<li>找出所有两个升序元素对 $a_{i}&lt;a_{i+1}$ 中索引最大的为 i，则 $a_{i+1}, …, a_{n}$ 称为最长递减后缀；</li>
<li>找到最长递减后缀中大于 $a_{i}$ 的最小元素，即：找到使得 $a_{i}&lt;a_{j}$ 的最大索引 j；</li>
<li>交换 $a_{i}$ 和 $a_{j}$；</li>
<li>将新后缀 $a_{i+1}, …, a_{n}$ 颠倒，变为递增的；</li>
<li>输出最后的排列，返回步骤 2。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr29A/01.png" alt="01.png"></p>
<h1 id="减常因子形式"><a href="#减常因子形式" class="headerlink" title="减常因子形式"></a>减常因子形式</h1><p>与减常量形式不不同，减常因子减去的是某一个固定比例的实例，比如：原实例的一半</p>
<h2 id="eg-折半查找"><a href="#eg-折半查找" class="headerlink" title="eg. 折半查找"></a>eg. 折半查找</h2><p>将数组分成两半，比较待查找的键 K 和数组最中间的元素的大小关系，如果 K 大于 A[0], …, A[m], …, A[n-1]，则在后一半数组中继续查找，否则在前一半数组中继续查找，查找方式相同，知道找到元素或者数组无法分半为止</p>
<p>步骤：</p>
<ol>
<li>比较数组中间元素即下标为 m 的元素和键值 K 的大小关系，确定下一次查找的子数组的左右边界；</li>
<li>在新的子数组中查找，直到找到元素或者子数组长度为空。</li>
</ol>
<p>时间复杂度分析：</p>
<p>因为每次比较数组长度都需要减少一半，设数组长度为 $2^k$，那么最坏的情况需要 k+1 次，就可以将数组长度折半到 1，此时比较次数为：$\log_{n+1}$，复杂度渐进函数为：$\log_{n}$</p>
<h2 id="eg-约瑟夫斯问题"><a href="#eg-约瑟夫斯问题" class="headerlink" title="eg. 约瑟夫斯问题"></a>eg. 约瑟夫斯问题</h2><p>将 n 个人从 1 编号到 n 并围成一圈，从 1 开始依次去掉第二个人，知道只剩一个人，求留下的人的编号是多少？</p>
<p>用 J(n, 2) 表示 n 个人，去掉每两个人中的后一个，最后剩下的人的编号</p>
<p>假设 n=6，那么第一圈去掉的编号是 2, 4, 6，第二圈去掉的编号是 1, 3，最后剩下的编号是 5，即：J(6， 2)=5</p>
<p>又假设 n=7，则 J(7, 2)=7</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr29A/02.png" alt="02.png"></p>
<p>当 n 为偶数：J(2k) = 2J(k)-1</p>
<p>当 n 为奇数：J(2k+1) = 2J(k)+1</p>
<p>简便求解：将 n 转换为二进制数，然后将二进制数循环左移 1 位，新的二进制数转换为十进制数，这个十进制数就是问题的解</p>
<p>eg. J(6) = J(1102) = 1021 = 5</p>
<h1 id="减可变因子形式"><a href="#减可变因子形式" class="headerlink" title="减可变因子形式"></a>减可变因子形式</h1><blockquote>
<p>即：减可变规模算法，减去的实例规模是不固定的</p>
</blockquote>
<h2 id="eg-快速选择算法"><a href="#eg-快速选择算法" class="headerlink" title="eg. 快速选择算法"></a>eg. 快速选择算法</h2><p>求 n 个数列表的第 k 个最小元素</p>
<p>思路：</p>
<p>如果针对数列的第一个元素，可以将数列分成：</p>
<ol>
<li>包含了数列中小于第一个元素的若干元素</li>
<li>数列中的第一个元素</li>
<li>大于第一个元素的若干元素</li>
</ol>
<p>经过划分就可以得知第一个元素是数列中第几小的元素，假设第一个元素 S，根据 k 和 S 的大小关系，可以选择继续在大于或者小于 S 的子数列中继续划分子数列，直到 S=k</p>
<p>通过划分就可以将问题的实例不断减小，且减小的规模不是固定的一个数值或者比例，而是可变化的，由于划分快速将实例规模变小了，并且选择了小规模实例继续进行划分，即：快速选择算法</p>
<p>效率分析：</p>
<p>最好情况：一次划分就找到指定元素，$T(n) = n-1 \in \Theta (n)$</p>
<p>最坏情况：经过 n-1 次划分才找到指定元素，$T(n) = (n-1) + (n-2) + … + 1 = \frac{(n-1)n}{2} \in \Theta (n^2)$</p>
<p>平均情况：$T(n) =   T(\frac{n}{2}) + (n+1) \in \Theta(n)$</p>
<p>对于选择问题，可以直接用排序方法求得一个有序数组，然后输出指定位置的元素，排序方法中有的算法效率比 $n^2$ 低，似乎基于排序的方法比快速选择算法更优，但是：<strong>快速选择算法在平均情况下的效率是线性的，优于基于排序的方法</strong></p>
]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析——蛮力法</title>
    <url>/20/04/28A/</url>
    <content><![CDATA[<p>没简介多简洁😴</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>定义：从问题的描述和定义中直接得出解的方法</p>
</blockquote>
<p>eg. 冒泡排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BubbleSort(A[0, ..., n-1])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该算法用冒泡排序对给定数组排序</span><br><span class="line">&#x2F;&#x2F; 输入：一个可排序的数组 A[0, ..., n-1]</span><br><span class="line">&#x2F;&#x2F; 输出：非降序排列的数组 A[0, ..., n-1]</span><br><span class="line"></span><br><span class="line">for i⬅0 to n-2 do</span><br><span class="line">    for j⬅0 to n-2-i do</span><br><span class="line">        if A[j+1] &lt; A[j]</span><br><span class="line">            swap A[j] and A[j+1]</span><br></pre></td></tr></table></figure>

<p>一般用来解决一些比较广阔的领域问题，并不是针对某一特定领域的问题，也能够用于产生问题的一些合理方法</p>
<p>通常当问题的实例规模比较小，或者说问题的数据量比较小的时候，蛮力法的代价比较小，可以选择它来解决问题</p>
<p>蛮力法的结果可以被用作其他高效算法的衡量标准，来比较这些高效算法的效率和正确性</p>
<h1 id="最近对和凸包问题"><a href="#最近对和凸包问题" class="headerlink" title="最近对和凸包问题"></a>最近对和凸包问题</h1><blockquote>
<p>最近对问题：在包含 N 个点的集合中找出距离最近的两个点</p>
</blockquote>
<p>蛮力法：</p>
<p>$$d(P_{i}, P_{j}) = \sqrt{(x_{i} - x_{j})^2 + (y_{i} - y_{j})^2}$$</p>
<p>分别计算每两个点之间的距离，找出其中距离最小的两个点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BruteForceClosestPoints(P)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输入：一个包好 n(n &gt;&#x3D; 2) 个点坐标的列表 P</span><br><span class="line">&#x2F;&#x2F; 输出：两个距离最近的点的坐标</span><br><span class="line"></span><br><span class="line">dmin ⬅ ∞</span><br><span class="line">for i⬅1 to n-1 do</span><br><span class="line">    for j⬅i+1 to n do</span><br><span class="line">        d ⬅ sqrt((xi - xj)^2 + (yi -yj)^2)</span><br><span class="line">        if d &lt; dmin</span><br><span class="line">            dmin ⬅ d;</span><br><span class="line">            index1 ⬅ i;</span><br><span class="line">            index2 ⬅ j</span><br><span class="line">return index1, index2</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$n^2$</p>
<blockquote>
<p>凸包：给定点集中的一个近似</p>
</blockquote>
<p>一个点集合 S 的凸包是包含点集合 S 的最小的凸集合，我们说一个点集合是凸起的，就是说以集合中任意两点 P 和 Q 为端点的线段都属于这个集合</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr28A/00.png" alt="00.png"></p>
<p>如图，凸包就是边界点连接围成的区域，也就是以点集合中某些点为顶点的一个凸多边形，这些顶点被称为极点</p>
<p>思路：任意选择点集合中的两个点 $P_{i}$ 和 $P_{j}$，如果发现点集合中其他的点都位于穿过连接这两个点的直线的同侧，那么这两个点的连线 $P_{i}P_{j}$ 就是凸包边界的一部分，找出所有满足条件的点</p>
<p>$P_{i}$ 和 $P_{j}$ 的直线方程：$ax + by = c$</p>
<p>如果把点集合中的其他点的坐标代入式子：$ax + by - c$，如果结果符号相同，就表示其他点都位于 $P_{i}$ 和 $P_{j}$ 的同侧，那么这两个点 $P_{i}$ 和 P_{j} 就是凸包的一部分</p>
<p>由于对于 N 个点的集合来说，不同点的选择有 $\frac{n(n-1)}{2}$ 个，每次选择需要对其他 $n-2$ 个点做测试，因此这种算法的时间复杂度为：$n^3$</p>
<h1 id="穷举问题"><a href="#穷举问题" class="headerlink" title="穷举问题"></a>穷举问题</h1><p>eg. 旅行商问题</p>
<p>一个旅行商，从一个城市出发，经过城市与城市之间的道路，将所有的城市访问一次来推销自己的商品，然后回到最初出发的城市，<strong>问：如何制定一个距离最短的访问顺序来节约旅行成本？</strong></p>
<p>思路（穷举查找）：把所有访问城市可能的顺序列举出来，计算每一个顺序的距离，最后选择距离最短的一条</p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr28A/01.png" alt="01.png"></p>
<p>对于要经过 n 个城市的旅行商问题，路径的可能性是 $(n-1)!$</p>
<p>eg. 背包问题</p>
<p>有 N 个物品，每个物品都有重量和价值，重量：$w_{1}, w_{2}, …, w_{n}$，价值：$v_{1}, v_{2}, …, v_{n}$，有一个容量为 W 的背包，这个背包的承重不能超过 W，<strong>求：如何装入物品才能使背包不超重且价值最大？</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/TUFZ/ImgHosting//TUFZ-Img/article/2020/04/20Apr28A/02.png" alt="02.png"></p>
<p>如果物品的数量是 n 个，穷举的数量是 $2^n-1$</p>
<h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1><p>通过问题的描述或者问题的概念，制定出一种简单而直接的解决问题的方案</p>
<p>但是：这只能针对规模很小的问题才具有适用性和简单性</p>
<p><strong>通常来说蛮力法的效率都不够高</strong></p>
]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel 公式应用与数据处理</title>
    <url>/20/05/23A/</url>
    <content><![CDATA[<blockquote>
<p>仅记录部分知识点</p>
</blockquote>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">作用</th>
<th align="center">eg.</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%</td>
<td align="center">将数值转换成百分比格式</td>
<td align="center">(15+25)% = 40%</td>
</tr>
<tr>
<td align="center">&lt;&gt;</td>
<td align="center">比较两个数值是否不相等</td>
<td align="center">A1&lt;&gt;B2</td>
</tr>
<tr>
<td align="center">:(冒号)</td>
<td align="center">引用两个单元格地址间所有的单元格</td>
<td align="center">A1:B5</td>
</tr>
<tr>
<td align="center">,(逗号)</td>
<td align="center">引用多个不连续的单元格或区域</td>
<td align="center">A1,B2:B4</td>
</tr>
<tr>
<td align="center">(空格)</td>
<td align="center">引用两个区域间的共有单元格区域</td>
<td align="center">SUM(A1:B4 B2:D6)</td>
</tr>
</tbody></table>
<p>文本运算符 <code>&amp;</code> 是用于连接文本的符号，可以将两个文本字符串进行连接</p>
<p>使用 <code>()</code> 可以避免运算符优先级混乱</p>
<p>绝对引用时，在单元格地址行号和列标前都加上绝对引用符号 <code>$</code>，eg. $C$3，表示单元格 C3 是绝对引用</p>
<p>在不同工作表公式格式的引用：<code>工作表名称! 列标行号</code>，eg. 在 Sheet1 工作表中 <code>D4=Sheet2! B4+Sheet3! C4</code></p>
<p>在不同工作簿公式格式的引用：<code>[工作簿名称]工作表名称! 列标行号</code>，eg. 在 book1 工作簿中 <code>D4=[book2]Sheet2! B4+[book3]Sheet3! C4</code></p>
<p>在不同磁盘的不同工作簿公式格式的引用：<code>&#39;磁盘路径[工作簿名称]工作表名称&#39;! 列标行号</code>，eg. <code>D4=&#39;d:\aaa\[book2]Sheet2&#39;! B4+&#39;e:\ccc\[book3]Sheet3&#39;! C4</code></p>
]]></content>
      <tags>
        <tag>数据处理</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>0.print()函数</title>
    <url>/20/09/28A/</url>
    <content><![CDATA[<p>Python 基础语法系列开“🕳”。</p>
<a id="more"></a>

<h1 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h1><p>Python 的语言逻辑已经高度接近人类语言。</p>
<p>Python 程序的执行过程大致如下：</p>
<p>eg. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;see what see!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="0">
<li>我们使用 Python 向计算机发出指令；</li>
<li>Python 解释器将代码编译成计算机能够理解的机器语言；</li>
<li>计算机执行相应指令；</li>
<li>输出指令执行后的结果。</li>
</ol>
<p>注意 <code>print(1 + 1)</code> 与 <code>print(&#39;see what see!&#39;)</code> 的区别：</p>
<p>计算机可以很容易地读懂数学运算，因为数学运算是非常标准的，所以可以直接输入运算式子；但是对于文本信息，计算机不能对其进行运算，所以需要一个<strong>引号</strong>告诉计算机：不用运算，直接输出。</p>
<h1 id="三引号"><a href="#三引号" class="headerlink" title="三引号"></a>三引号</h1><p>在 <code>print()</code> 中使用三引号可以让文本换行打印。</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">从明天起，做一个幸福的人</span></span><br><span class="line"><span class="string">喂马，劈柴，周游世界</span></span><br><span class="line"><span class="string">从明天起，关心粮食和蔬菜</span></span><br><span class="line"><span class="string">我有一所房子，面朝大海，春暖花开</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>从明天起，做一个幸福的人<br>喂马，劈柴，周游世界<br>从明天起，关心粮食和蔬菜<br>我有一所房子，面朝大海，春暖花开</p>
</blockquote>
]]></content>
      <categories>
        <category>Python 自学笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>1.input()函数与变量</title>
    <url>/20/09/28B/</url>
    <content><![CDATA[<p>学习整数和字符串这两种数据类型、<code>input()</code> 函数和注释的使用。</p>
<a id="more"></a>

<h1 id="整数和字符串"><a href="#整数和字符串" class="headerlink" title="整数和字符串"></a>整数和字符串</h1><p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">1</span> + <span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;see what see!&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;就看你咋了？&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>1</code> 就是<strong>整数</strong>，而 <code>&#39;see what see!&#39;</code> 和 <code>&#39;就看你咋了？&#39;</code> 都是<strong>字符串</strong>，用单引号括起来的文本就是字符串。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量就是一个带标签的盒子，里面用来存放数据。</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>num</code> 就是变量名，而 <code>3</code> 就是变量值，这行代码意思就是把 3 这个整数存放进变量 num 里（称之为<strong>赋值</strong>），变量名是可以自己设定的（但是必须遵守一定的命名规则！）。</p>
<p><strong>注意</strong>：赋值的 <code>=</code> 和等于的 <code>=</code> 完全不一样，赋值是把等号右边的值赋给等号左边的变量，而等于就是等于。</p>
<p>赋值 like this: <code>num ⬅ 3</code></p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">3</span></span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>3</p>
</blockquote>
<p>以上！我们定义了一个变量 <code>num</code>，把整数 <code>3</code> 赋值给 <code>num</code>，然后打印 <code>num</code>，由此可见：</p>
<ul>
<li>计算机运行程序时是一行一行的执行代码语句的</li>
<li>变量必须经过定义和赋值才可以使用</li>
</ul>
<p>变量！是指没有固定的值，可以改变的数。所以说变量是可变的：</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num  = <span class="number">3</span></span><br><span class="line">num = num + <span class="number">2</span></span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>5</p>
</blockquote>
<p>变量还可以支持不同数据类型的赋值（eg. 字符串、整数 etc.）</p>
<h1 id="input"><a href="#input" class="headerlink" title="input()"></a>input()</h1><p>输入！input() 函数的作用就是让用户通过键盘输入内容，然后点击回车程序继续运行。</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input(<span class="string">&#x27;Do U like me?&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>input() 括号里的内容是用来提示用户的信息，如果要使用用户输入的信息就需要用上变量了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = input(<span class="string">&#x27;你有几块钱？&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;我有 &#x27;</span> + a + <span class="string">&#x27;块钱！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在这里，我们使用变量 <code>a</code> 来接收了用户的输入，用户输入的数据就赋值给了变量 a，那么我们就可以通过使用 a 来使用用户输入的数据。</p>
<p><strong>注意</strong>：input() 函数会把用户输入的内容以<strong>字符串</strong>的数据类型保存。</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>Python 的注释符号是 <code>#</code>，计算机运行代码时会自动跳过 # 之后的内容，合理地使用注释可以帮助我们更好地理解代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 学习 + 的用法</span></span><br><span class="line">a = input(<span class="string">&#x27;你有几块钱？&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;我有&#x27;</span> + a + <span class="string">&#x27;块钱！&#x27;</span>)</span><br><span class="line"><span class="comment"># 在 print() 函数中，通过 + 可以连接字符串</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python 自学笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>2.数据类型</title>
    <url>/20/09/28C/</url>
    <content><![CDATA[<p>如题。</p>
<a id="more"></a>

<p>计算机是做数学运算的机器，它不仅可以处理各种数值，还可以处理文本、音频、视频、图形图像等数据。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><blockquote>
<p>string，计算机中一般简写：str</p>
</blockquote>
<p>字符串的呈现方式一般是用<strong>单引号</strong>或者<strong>双引号</strong>括起来的文本，eg. <code>&#39;中国&#39;</code>、<code>&quot;cHINA&quot;</code> etc.</p>
<p>使用单引号或者是双引号都是一样的效果，而且单引号和双引号只是一种表达方式，它<strong>不属于字符串的一部分</strong>。</p>
<p>💢如果字符串内部包含了单引号【<code>&#39;&#39;</code>】或者双引号【<code>&quot;&quot;</code>】的话，就需要转义字符【<code>\</code>】来标识。</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意：这是错误的</span></span><br><span class="line">print(<span class="string">&#x27;Let&#x27;</span>s go! go! go!<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p> SyntaxError: invalid syntax </p>
</blockquote>
<p>以上，Python 会报错说“语法错误”，因为 Python 会从左到右匹配引号，所以在这个语句中，<code>Let</code> 被识别成了字符串，那么后面的 <code>s go! go! go!&#39;</code> 计算机就理解不了了，于是产生了错误。</p>
<p>当我们使用转义字符后：</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转义字符【\】可以改变连接在其后的字符的本意，使其后的【&#x27;】不再具备标记字符串的功能</span></span><br><span class="line">print(<span class="string">&#x27;Let\&#x27;s go! go! go!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>Let’s go! go! go!</p>
</blockquote>
<p>对于这样的问题，除了使用转义字符，还可以这样：</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;Let&#x27;s go! go! go!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>Let’s go! go! go!</p>
</blockquote>
<p>因为使用了 <code>&quot;&quot;</code> 来标记字符串，与 Let’s 内部的单引号有所不同了，所以 Python 就能够区分它们。</p>
<p>当然这可以这么用：</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;川普说：&quot;CHINA IS THE BEST!&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>川普说：”CHINA IS THE BEST!”</p>
</blockquote>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>这是另外一种转义字符，用来换行：</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;1x1=1 \n 1x2=2 2x2=4 \n 1x3=3 2x3=6 3x3=9&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>1x1=1</p>
<p>1x2=2 2x2=4</p>
<p>1x3=3 2x3=6 3x3=9</p>
</blockquote>
<p>更多的转义字符：</p>
<p><img src="https://gitee.com/waringhu/assets/raw/master/img/image-20200626164658226.png" alt="image-20200626164658226"></p>
<h1 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h1><p>用于获取数据的数据类型：</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">&#x27;人类懂王&#x27;</span></span><br><span class="line">print(type(flag))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>&lt;class ‘str’&gt;</p>
</blockquote>
<p>这里，<code>class</code> 表示类，而 <code>str</code> 表示字符串，所以这里的 <code>flag</code> 里存放的是一个<em>字符串的类</em>。</p>
<h1 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h1><p>用于获取数据的长度：</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">&#x27;没人比我更懂病毒&#x27;</span></span><br><span class="line">print(len(flag))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>8</p>
</blockquote>
<p>表示这里的 <code>flag</code> 里存放的字符串的长度是：<code>8</code></p>
<h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><blockquote>
<p>integer，简写为：int</p>
</blockquote>
<p>Python 可以处理任意大小的整数，包括负整数，在程序中的表示方法和数学上的一模一样。</p>
<p>Python 中整数可以做的运算类型：</p>
<p><img src="https://gitee.com/waringhu/assets/raw/master/img/image-20200626170049456.png" alt="image-20200626170049456"></p>
<p>注意：<code>3</code> 和 <code>&#39;3&#39;</code> 有什么区别？</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(type(<span class="number">3</span>))</span><br><span class="line">print(type(<span class="string">&#x27;3&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>&lt;class ‘int’&gt;</p>
<p>&lt;class ‘str’&gt;</p>
</blockquote>
<p>而且，整数这个数据类型是没有 len() 函数的：</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(len(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p> TypeError: object of type ‘int’ has no len() </p>
</blockquote>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><blockquote>
<p>float，没有简写</p>
</blockquote>
<p>带有小数点的数字都是浮点数，浮点数和整数在计算机内部的存储方式是不同的。</p>
<p>而且，<strong>整数运算永远是精确的（包括除法）</strong>，但是浮点数的运算则可能存在四舍五入的误差。</p>
<p>浮点数这个数据类型也是没有 len() 函数的，也就是浮点数这个类型没有长度。</p>
<h1 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h1><p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="number">0</span></span><br><span class="line">print(<span class="string">&#x27;女装只有&#x27;</span> + flag + <span class="string">&#x27;次和无数次！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>你以为会是：<code>女装只有0次和无数次！</code></p>
<p>输出：</p>
<blockquote>
<p>TypeError: must be str, not int </p>
</blockquote>
<p>意思是类型错误：必须是字符串，而不是整数。</p>
<p>这表明整数和字符串两个不同的数据类型是不可以直接通过 + 连接的，所以我们必须转换数据类型，只有相同的数据类型才可以通过 + 连接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将其他数据类型转换成字符串</span></span><br><span class="line">str()</span><br><span class="line"><span class="comment"># 将其他数据类型转换成整数</span></span><br><span class="line">int()</span><br><span class="line"><span class="comment"># 将其他数据类型转换成浮点数</span></span><br><span class="line">float()</span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="number">0</span></span><br><span class="line">print(<span class="string">&#x27;女装只有&#x27;</span> + str(flag) + <span class="string">&#x27;次和无数次！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>女装只有0次和无数次！</p>
</blockquote>
]]></content>
      <categories>
        <category>Python 自学笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>3.条件判断</title>
    <url>/20/09/30A/</url>
    <content><![CDATA[<p>条件判断就是明确计算机在什么条件下执行什么命令。</p>
<a id="more"></a>

<h1 id="if…"><a href="#if…" class="headerlink" title="if…"></a>if…</h1><p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = int(input(<span class="string">&#x27;1 + 1 等于几？&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">&#x27;你可真是个机灵鬼！&#x27;</span>)</span><br><span class="line"><span class="comment"># 注意这里缩进了 4 个空格</span></span><br></pre></td></tr></table></figure>

<p>注意：这里的 <code>==</code> 与 <code>=</code> （赋值）是有区别的，<code>==</code> 表示等于。</p>
<p>以上代码，当输入 2 时，程序输出：你可真是个机灵鬼！当输入不等于 2 时，程序什么也不会执行，因为不满足进一步的条件。</p>
<p>if 后面跟着一个条件，当条件为真，程序执行 if 内部的指令，否则程序跳出 if，执行 if 外部的指令。</p>
<p><strong>注意</strong>：if 的条件后面有一个英文冒号【<code>:</code>】，if 内部的语句都要缩进 4 个空格。</p>
<h1 id="if…else…"><a href="#if…else…" class="headerlink" title="if…else…"></a>if…else…</h1><p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = int(input(<span class="string">&#x27;1 + 1 等于几？&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">&#x27;你可真是个机灵鬼！&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;emmm!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以上多了一个 <code>else</code>，表示否则，也就是说当 if 后的条件为假时，程序执行 else 后的指令。</p>
<p><strong>注意</strong>：if 后面有一个英文冒号【<code>:</code>】，<em>else 后面也有</em>，if 内部的语句都要缩进 4 个空格，<em>else 内部的语句也要缩进 4 个空格</em>。</p>
<h1 id="if…elif…else…0"><a href="#if…elif…else…0" class="headerlink" title="if…elif…else…0"></a>if…elif…else…0</h1><p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = int(input(<span class="string">&#x27;1 + 1 等于几？&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">&#x27;你可真是个机灵鬼！&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> flag &lt; <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">&#x27;太小了！&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;太大了！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里有一个 <code>elif</code>，其实就是 else if 的缩写，表示否则如果。</p>
<p>而且这个 elif 是可以根据实际情况重复使用的：</p>
<p>eg.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ...:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">elif</span> ...:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">elif</span> ...:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>程序执行的原理以及注意事项与之前的完全一样。</p>
<p>条件判断就是一种控制流，控制流下的语句会依照一些特定的规则，控制程序走向。</p>
]]></content>
      <categories>
        <category>Python 自学笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
</search>
