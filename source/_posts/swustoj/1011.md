---
title: "#1011 二叉排序树的实现和查找"
date: 2019-04-26 23:03:48
tags:
- "SWUST"
- "OJ"
categories: "SWUSTOJ 题解系列"
---

# 题目

> 按照给定的关键字集合，建立二叉排序树。在建立的二叉排序树上查找指定的关键字，查找成功，输出找到该关键字比较的次数；查找不成功，输出-1.

<!-- more -->

## 输入

> 关键字个数n； 
关键字集合； 
要查找的关键字。

## 输出

> 查找成功输出比较的次数，否则输出-1。

## 样例输入

> 12
25 18 46 2 53 39 32 4 74 67 60 11
74

## 样例输出

> 4

# 源代码

```cpp
#include <iostream>

using namespace std;

int Count = 1;
int flag = 0;
class treenode
{
	friend class tree;
public:
	treenode(int a) :data(a)
	{
		left = NULL;
		right = NULL;
	}
private:
	int data;
	treenode* left;
	treenode* right;
};
class tree
{
public:
	tree() :root(NULL){}
	void insert(treenode*  & T,treenode*&);
	int find(int x,treenode* current);
	treenode* root;
};

void tree::insert(treenode* & T,treenode* &current)
{
	if (current == NULL)
	{
		current = T;
	}
	if (current->data>T->data)
	{
		insert(T, current->left);
	}
	if (current->data < T->data)
	{
		insert(T, current->right);
	}
}

int tree::find(int x,treenode* current)
{
	if (current->data == x)
	{
		flag = 1;
		return Count;
	}
	else
	{
		if (x > current->data)
		{
			if (current->right)
			{
				Count++;
				find(x,current->right);
			}
			else
			{
				return -1;
			}
		}
		if (x < current->data)
		{
			if (current->left)
			{
				Count++;
				find(x, current->left);
			}
			else
			{
				return -1;
			}
		}
	}
}

int main()
{
	tree T;
	int n;
	int x;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> x; 
		treenode* temp = new treenode(x);
		T.insert(temp,T.root);
	}
	int a;
	cin >> a;
	T.find(a, T.root);
	if (flag==0)
		cout<<-1;
	else
	cout << Count;
	return 0;
}
```
