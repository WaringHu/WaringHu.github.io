---
title: "#1068 图的按录入顺序深度优先搜索"
date: 2019-04-28 00:21:55
tags:
- "SWUST"
- "OJ"
categories: "SWUSTOJ 题解系列"
---

# 题目

> 图的深度优先搜索类似于树的先根遍历，即从某个结点开始，先访问该结点，然后深度访问该结点的第一棵子树，依次为第二顶子树。如此进行下去，直到所有的结点都访问为止。在该题中，假定所有的结点以“A”至“Z”中的若干字符表示，且要求结点的访问顺序根据录入的顺序进行访问。如果结点录入的顺序为HUEAK，从H开始进行深度优先搜索，则可能的搜索结果为：H->A->K->U>E.

<!-- more -->

## 输入

> 第一行为一个整数n，表示顶点的个数，第二行为n个大写字母构成的字符串，表示顶点，接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为0表示不邻接，否则为相应的边的长度。最后一行为一个字符，表示要求进行深度优先搜索的起始顶点。

## 输出

> 用一行输出深度优先搜索结果，起始点为给定的顶点。

## 样例输入

> 5
HUEAK
0 0 2 3 0
0 0 0 7 4
2 0 0 0 0
3 7 0 0 1
0 4 0 1 0
H

## 样例输出

> HEAUK

# 源代码

```cpp
#include <iostream>
#include <stack>

using namespace std;

int main()
{
	stack<int> s;
	int n;
	cin >> n;
	char str[100];
	char strr[100][2];
	cin >> str;
	for (int i = 0; i < n; i++)
	{
		strr[i][0] = str[i];
		strr[i][1] = '0';
	}
	int arr[100][100];
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			cin >> arr[i][j];
		}
	}
	char a;
	int b;
	cin >> a;
	for (int i = 0; i<n; i++)
	{
		if (strr[i][0] == a)
		{
			b = i;
			break;
		}
	}
	strr[b][1] = '1';
	s.push(b);
	cout << strr[b][0];
	while (s.size()>0)
	{
		int x;
		int flag = 0;
		int v = s.top();
		for (int i = 0; i < n; i++)
		{
			if (arr[v][i] >0 && strr[i][1] == '0')
			{
				x = i;
				flag = 1;
				break;
			}
			else
			{
				flag = 0;
			}
		}
		if (flag == 1)
		{
			strr[x][1] = '1';
			cout << strr[x][0];
			s.push(x);
		}
		else
		{
			s.pop();
		}
	}
	return 0;
}
```
