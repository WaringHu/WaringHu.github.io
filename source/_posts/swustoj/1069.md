---
title: "#1069 图的按录入顺序广度优先搜索"
date: 2019-04-28 00:26:03
tags:
- "SWUST"
- "OJ"
categories: "SWUSTOJ 题解系列"
---

# 题目

> 图的广度优先搜索类似于树的按层次遍历，即从某个结点开始，先访问该结点，然后访问该结点的所有邻接点，再依次访问各邻接点的邻接点。如此进行下去，直到所有的结点都访问为止。在该题中，假定所有的结点以“A”--“Z”中的若干字符表示，且要求结点的访问顺序根据录入的顺序进行访问。如果结点录入的顺序为HUEAK，要求从H开始进行广度优先搜索，则可能的搜索结果为：H->E->A->U->K.

<!-- more -->

## 输入

> 第一行为一个整数n，表示顶点的个数，第二行为n个大写字母构成的字符串，表示顶点，接下来是为一个n*n大小的整数矩阵，表示图的邻接关系。数字为0表示不邻接，否则为相应的边的长度。最后一行为一个字符，表示要求进行广度优先搜索的起始顶点。

## 输出

> 用一行输出广度优先搜索结果，起始点为给定的顶点。

## 样例输入

> 5
HUEAK
0 0 2 3 0
0 0 0 7 4
2 0 0 0 0
3 7 0 0 1
0 4 0 1 0
H

## 样例输出

> HEAUK

# 源代码

```cpp
#include <iostream>
#include <queue>

using namespace std;

int main()
{
	queue<int> s;
	int n;
	cin >> n;
	char str[100];
	char strr[100][2];
	cin >> str;
	for (int i = 0; i < n; i++)
	{
		strr[i][0] = str[i];
		strr[i][1] = '0';
	}
	int arr[100][100];
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			cin >> arr[i][j];
		}
	}
	char a;
	int b;
	cin >> a;
	for (int i = 0; i<n; i++)
	{
		if (strr[i][0] == a)
		{
			b = i;
			break;
		}
	}
	strr[b][1] = '1';
	s.push(b);
	cout << strr[b][0];
	while (s.size()>0)
	{
		int flag = 0;
		int v = s.front();
		for (int i = 0; i < n; i++)
		{
			if (arr[v][i] >0 && strr[i][1] == '0')
			{
				flag = 1;
				strr[i][1] = '1';
				cout << strr[i][0];
				s.push(i);
			}
		}
		s.pop();
	}
	return 0;
}
```
