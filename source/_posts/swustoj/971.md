---
title: "#971 统计利用先序遍历创建的二叉树的深度"
date: 2019-04-25 23:09:48
tags:
- "SWUST"
- "OJ"
categories: "SWUSTOJ 题解系列"
---

# 题目

> 利用先序递归遍历算法创建二叉树并计算该二叉树的深度。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符"#"时表示该结点不需要创建，否则创建该结点。最后再统计创建完成的二叉树的深度（使用二叉树的后序遍历算法）。需要注意输入数据序列中的"#"字符和非"#"字符的序列及个数关系，这会最终决定创建的二叉树的形态。

<!-- more -->

## 输入

> 输入为先序遍历二叉树结点序列。

## 输出

> 对应的二叉树的深度。

## 样例输入

> A##
> ABC####
> AB##C## 
> ABCD###E#F##G## 
> A##B##

## 样例输出

> 1
> 3 
> 2
> 4
> 1

# 源代码

```cpp
#include<iostream>
#include<queue>

using namespace std;

int i = 0;
class binarytree;
class TreeNode
{
	friend class binarytree;
public:
	void getleft(TreeNode * p)
	{
		leftnode = p;
	}
	void getright(TreeNode *p)
	{
		rightnode = p;
	}
	TreeNode(char a) { data = a; leftnode = NULL; rightnode = NULL; };
	char data;
	TreeNode *leftnode;
	TreeNode *rightnode;
};
class binarytree
{
public:
	void getroot(TreeNode* p)
	{
		root = p;
	}

	int preoder();											//后序遍历
	int preoder(TreeNode* current,int h1,int h2);
	void preinsert(TreeNode* &current, char* arr);
	TreeNode * root;
};
int binarytree::preoder()
{
	int h1=1, h2=1;
	return preoder(root,h1,h2);
}
int h = 0;
int binarytree::preoder(TreeNode* current,int h1,int h2)
{
	if (current)
	{
		if (h1 >= h2&&h1 > h)
			h = h1;
		else if (h2 >= h1&&h2 > h)
			h = h2;
		h1++;
		preoder(current->leftnode,h1,h2);
		h2++;
		preoder(current->rightnode,h2,h2);
	}
	return h;
}
void binarytree::preinsert(TreeNode* &current, char* arr)		//注意这里的是引用地址
{
	if (arr[i] == '#')
	{
		current = NULL;
		i++;
	}
	else
	{
		current = new TreeNode(arr[i]);
		i++;
		preinsert(current->leftnode, arr);
		preinsert(current->rightnode, arr);
	}
}

int main()
{
	binarytree Tree;
	char arr[1000];
	cin >> arr;
	Tree.preinsert(Tree.root, arr);
	cout<< Tree.preoder();
	return 0;
}
```
