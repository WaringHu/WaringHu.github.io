---
title: "#980 输出利用先序遍历创建的二叉树的层次遍历序列"
date: 2019-04-26 22:21:44
tags:
- "SWUST"
- "OJ"
categories: "SWUSTOJ 题解系列"
---

# 题目

> 利用先序递归遍历算法创建二叉树并输出该二叉树的层次遍历序列。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符"#"时表示该结点不需要创建，否则创建该结点。最后再输出创建完成的二叉树的层次遍历序列。需要注意输入数据序列中的"#"字符和非"#"字符的序列及个数关系，这会最终决定创建的二叉树的形态。

<!-- more -->

## 输入

> 输入为接受键盘输入的由大写英文字符和"#"字符构成的一个字符串（用于创建对应的二叉树）。

## 输出

> 每个用例用一行出该用例对应的二叉树的层次遍历序列。

## 样例输入

> A##
ABC####
AB##C##
ABCD###EF##G##H##
A##B##

## 样例输出

> A
ABC
ABC
ABHCEDFG
A

# 源代码

```cpp
#include <iostream>
#include <queue>

using namespace std;

class Tree;
class treenode
{
	friend class Tree;
public:
	treenode(char a):data(a),left(NULL),right(NULL){}
private:
	char data;
	treenode* left;
	treenode* right;
};
class Tree
{
public:
Tree():root(NULL){}
void precreate(treenode* &current,queue<char>&);
void levoder();
void levoder(treenode*,queue<treenode*>);
treenode* root;
};

void Tree::precreate(treenode* &current,queue<char>& Q)
{
	if(Q.empty())
		return ;
	if(Q.front()!='#')
	{
		treenode* node=new treenode(Q.front());
		Q.pop();
		current=node;
		precreate(current->left,Q);
		precreate(current->right,Q);
	}
	else
	{
		Q.pop();
	} 
}
void Tree::levoder()
{
	queue<treenode*> Q;
	if(root)
	Q.push(root);
	else
	{
		cout<<"空树！"<<endl;
	}
	levoder(root,Q);
}
void Tree::levoder(treenode* current,queue<treenode*> Q)
{	
	treenode* temp=Q.front();
	Q.pop();
	if(temp->left) Q.push(temp->left);
	if(temp->right) Q.push(temp->right);
	cout<<temp->data;
	if(!Q.empty()) levoder(Q.front(),Q);
}

int main(int argc, char* argv[])
{
	queue<char> Q;
	char a[1000];
	cin>>a;
	for(int i=0;a[i]!='\0';i++)
	{
		Q.push(a[i]);
	}
	Tree mytree;
	mytree.precreate(mytree.root,Q);
	mytree.levoder();
	return 0;
}
```
