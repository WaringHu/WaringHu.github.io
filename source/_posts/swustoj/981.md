---
title: "#981 统计利用二叉树存储的森林中树的棵数"
date: 2019-04-26 22:25:44
tags:
- "SWUST"
- "OJ"
categories: "SWUSTOJ 题解系列"
---

# 题目

> 普通树及其构成的森林均可转换成相应的二叉树，反之亦然。故而可以根据相应的转换方法去统计某一二叉树对应的森林中树的棵数。相应的二叉树可利用先序递归遍历算法创建。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符"#"时表示该结点不需要创建，否则创建该结点。最后再统计该二叉树对应的森林中树的棵数。需要注意输入数据序列中的"#"字符和非"#"字符的序列及个数关系，这会最终决定创建的二叉树的形态（序列里面允许无效字符但需要正确处理）。

<!-- more -->

## 输入

> 输入为接受键盘输入的由大写英文字符和"#"字符构成的一个字符串（用于创建对应的二叉树）。

## 输出

> 输出该用例对应的二叉树表示的森林中树的棵数。

## 样例输入

> A#B#CD###
ABC####
AB##C##
ABCD###EF##G##H##
A##B##

## 样例输出

> 3
1
2
2
1

# 源代码

```cpp
#include <iostream>
#include <queue>

using namespace std;

class treenode
{
	friend class Tree;
public:
	treenode(char a):data(a),leftnode(NULL),rightnode(NULL){}
private:
char data;
treenode* leftnode;
treenode* rightnode;		
};
class Tree
{
public:
	Tree():root(NULL),count(1){}
	void precreate(treenode*&,queue<char> &Q);
	int treenum(treenode* current); 

treenode* root;
int count;	
};
void Tree::precreate(treenode* & current,queue<char> &Q)
{
	if(Q.empty())
	return ;
	if(Q.front()!='#')
	{
		treenode* temp=new treenode(Q.front());
		Q.pop();
		current=temp;
		precreate(current->leftnode,Q);
		precreate(current->rightnode,Q);
	}
	else
	{
		Q.pop();
	}
}
int Tree::treenum(treenode* current)
{
	if(current->rightnode)
	{
		count++;
		treenum(current->rightnode);
	}
	return count;
}
int main()
{
	Tree mytree;
	queue<char> Q;
	char arr[1000];
	cin>>arr;
	for(int i=0;arr[i]!='\0';i++)
	{
		Q.push(arr[i]);
	}
	mytree.precreate(mytree.root,Q);
	cout<<mytree.treenum(mytree.root);
	return 0;
} 
```
