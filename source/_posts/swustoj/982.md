---
title: "#982 输出利用二叉树存储的普通树的度"
date: 2019-04-26 22:31:42
tags:
- "SWUST"
- "OJ"
categories: "SWUSTOJ 题解系列"
---

# 题目

> 普通树可转换成相应的二叉树（该二叉树的根结点一定缺少右儿子），反之亦然。故而可以根据相应的转换方法去统计某一二叉树对应的普通树的度。普通树的度为其结点儿子数的最大值。相应的二叉树可利用二叉树的先序递归遍历算法创建。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符"#"时表示该结点不需要创建，否则创建该结点。最后再统计该二叉树对应的森林中树的棵数。需要注意输入数据序列中的"#"字符的序列及个数关系，这会最终决定创建的二叉树的形态（序列里面允许无效字符但需要正确处理）。

<!-- more -->

## 输入

> 输入为接受键盘输入的由大写英文字符和"#"字符构成的一个字符串（用于创建对应的二叉树）。

## 输出

> 若表示的二叉树对应普通树，则该普通树的度；否则输出ERROR。

## 样例输入

> AB#CD##E###
ABC####
AB##C##
ABCD###EF##G###
A##B##

## 样例输出

> 3
1
ERROR
3
1

# 源代码

```cpp
#include <iostream>
#include <queue>

using namespace std;

class treenode
{
	friend class Tree;
public:
	treenode(char a):data(a),leftnode(NULL),rightnode(NULL){}
private:
	char data;
	treenode* leftnode;
	treenode* rightnode;
};
class Tree
{
public:
	Tree():root(NULL),i(0){}
	void precreate(treenode* &current,queue<char> &Q);
	void normal_tree(treenode* current,int count[100]);
	bool check();
public:
	int i;
	treenode* root;
};
bool Tree::check()
{
	if(root->rightnode!=NULL)
		return false;
	else
		return true;
}
void Tree::precreate(treenode* &current,queue<char> &Q)
{
	if(Q.empty())
		return ;
	if(Q.front()!='#')
	{
		treenode* temp=new treenode(Q.front());
		current=temp;
		Q.pop();
		precreate(current->leftnode,Q);
		precreate(current->rightnode,Q);
	}
	else
	{
		Q.pop();
	}
}
void Tree::normal_tree(treenode* current,int count[100])
{
	if(!check())
	return ;
	if(current==NULL)
	return ;
	if(current->rightnode)
	{
		count[i]++;
		normal_tree(current->rightnode,count);
	}
	if(current->leftnode)
	{
		i++;
		normal_tree(current->leftnode,count);
	}
}

int main()
{
	queue<char> Q;
	char a[1000];
	int count[100];
	cin>>a;
	for(int k=0;a[k]!='\0';k++)
	{
		Q.push(a[k]);
	}
	for(int n=0;n<100;n++)
	{
		count[n]=1;
	}
	Tree mytree;
	mytree.precreate(mytree.root,Q);
	mytree.normal_tree(mytree.root,count);
	int max=0;
	for(int j=mytree.i;j>=0;j--)
	{
		if(count[j]>max)
		max=count[j];
		//cout<<count[j]<<endl;
	}
	if(mytree.check())
	cout<<max;
	else
	cout<<"ERROR";
	return 0;
}
```
