---
title: "#983 利用二叉树中序及后序遍历确定该二叉树的先序序列"
date: 2019-04-26 22:37:27
tags:
- "SWUST"
- "OJ"
categories: "SWUSTOJ 题解系列"
---

# 题目

> 已知二叉树的中序和先序遍历可以唯一确定后序遍历、已知中序和后序遍历可以唯一确定先序遍历，但已知先序和后序，却不一定能唯一确定中序遍历。现要求根据输入的中序遍历结果及后序遍历结果，要求输出其先序遍历结果。

<!-- more -->

## 输入

> 第一行为中序序列 
第二行为后续序列

## 输出

> 输出为遍历二叉树得到的先序序列

## 样例输入

> BFDAEGC
FDBGECA

## 样例输出

> ABDFCEG

# 源代码

```cpp
#include <iostream>

using namespace std;

class treenode
{
	friend class tree;
public:
	treenode(char a) :data(a)
	{
		left = NULL;
		right = NULL;
	}
private:
	char data;
	treenode* left;
	treenode* right;
};
class tree
{
public:
	tree() :root(NULL){}
	void create(treenode* & T, char *back, char *in, int n);
	void display(treenode* T);
	treenode* root;
};
void tree::create(treenode* & T, char *back, char *in, int n)
{
	if (n <= 0)
	{
		T = NULL;
		return;
	}
	int k;
	char* p;
	T = new treenode(*(back+n-1));
	for (p = in; p < in + n; p++)
	{
		if (*p == *(back+n-1))
			break;
	}
	k = p - in;
	create(T->right, (back + n - 1)-(n-1-k), in + k +1, n - k - 1);
	create(T->left, back, in, k);
	return;
}

void tree::display(treenode* T)
{
	if (T)
	{
		cout << T->data;
		display(T->left);
		display(T->right);
	}
}

int main()
{
	int n = 0;
	char ar_in[100];
	char ar_back[100];
	cin >> ar_in;
	cin >> ar_back;
	for (int i = 0; ar_back[i]; i++)
	{
		n++;
	}
	tree* T = new tree;
	T->create(T->root, ar_back, ar_in, n);
	T->display(T->root);
	return 0;
}
```
