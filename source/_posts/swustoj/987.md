---
title: "#987 输出用先序遍历创建的二叉树是否为完全二叉树的判定结果"
date: 2019-04-26 22:51:00
tags:
- "SWUST"
- "OJ"
categories: "SWUSTOJ 题解系列"
---

# 题目

> 利用先序递归遍历算法创建二叉树并判断该二叉树是否为完全二叉树。完全二叉树只能是同深度的满二叉树缺少最后一层倒数连续个叶子结点。先序递归遍历建立二叉树的方法为：按照先序递归遍历的思想将对二叉树结点的抽象访问具体化为根据接收的数据决定是否产生该结点从而实现创建该二叉树的二叉链表存储结构。约定二叉树结点数据为单个大写英文字符。当接收的数据是字符"#"时表示该结点不需要创建，否则创建该结点。最后判断创建完成的二叉树度是否为完全二叉树。需要注意输入数据序列中的"#"字符和非"#"字符的序列及个数关系，这会最终决定创建的二叉树的形态。

<!-- more -->

## 输入

> 输入为接受键盘输入的由大写英文字符和"#"字符构成的一个字符串（用于创建对应的二叉树）。

## 输出

> 对应的二叉树是否为完全二叉树的判断结果。若是输出"Y"，否则输出"N"。

## 样例输入

> A##
ABC####
AB##C##
ABCD###EF##G###
A##B##
ABC##D##EG###

## 样例输出

> Y
N
Y
N
Y
Y

# 源代码

```cpp
#include <iostream>
#include <queue>

using namespace std;

int flag = 0;
class treenode
{
	friend class tree;
public:
	treenode(char a) :data(a)
	{
		left = NULL;
		right = NULL;
	}
private:
	char data;
	treenode* left;
	treenode* right;
};
class tree
{
public:
	tree() :root(NULL){}
	void pre_create(treenode* &current, queue<char>&);
	bool check(treenode* root,queue<treenode*> &Q);
	treenode* root;
};

void tree::pre_create(treenode* &current, queue<char>& Q)
{
	if (Q.empty())
	{
		return;
	}
	if (Q.front() == '#')
	{
		Q.pop();
		current = NULL;
	}
	else
	{
		current = new treenode(Q.front());
		Q.pop();
		pre_create(current->left, Q);
		pre_create(current->right, Q);
	}
}

bool tree::check(treenode* current,queue<treenode*>& Q)
{
	if (current->left)
	{
		if (flag == 1)
		{
			return false;
		}
		else
		{
			Q.push(current->left);

		}
	}
	else
	{
		flag = 1;
	}
	if (current->right)
	{
		if (flag == 1)
		{
			return false;
		}
		else
			Q.push(current->right);
	}
	else
	{
		flag = 1;
	}
	Q.pop();
	if (Q.empty()&&flag==1)
	{
		return true;
	}
	if (!check(Q.front(), Q))
		return false;
	else
		return true;
}

int main()
{
	queue<char> Q1;
	queue<treenode*> Q2;
	char a[100];
	cin >> a;
	for (int i = 0; a[i] != '\0'; i++)
	{
		Q1.push(a[i]);
	}
	tree T;
	T.pre_create(T.root, Q1);
	Q2.push(T.root);
	if (T.check(T.root, Q2))
		cout << "Y";
	else
		cout << "N";
	return 0;
}
```
